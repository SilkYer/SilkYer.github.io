{"meta":{"title":"SilkYer's Blog","subtitle":"Write the code , Change the world","description":null,"author":"SilkYer","url":"https://silkyer.github.io"},"pages":[],"posts":[{"title":"Vue2.0仿外卖APP（五）","slug":"web-app05","date":"2017-05-16T14:25:27.413Z","updated":"2017-05-16T15:02:49.830Z","comments":true,"path":"2017/05/16/web-app05/","link":"","permalink":"https://silkyer.github.io/2017/05/16/web-app05/","excerpt":"","text":"header组件Vue-resource应用(当时的我还不知道axios..)https://github.com/pagekit/vue-resource vue-resource是Vue.js的一款插件，它可以通过XMLHttpRequest或JSONP发起请求并处理响应。也就是说，$.ajax能做的事情，vue-resource插件一样也能做到，而且vue-resource的API更为简洁。另外，vue-resource还提供了非常有用的inteceptor功能，使用inteceptor可以在请求前和请求后附加一些行为，比如使用inteceptor在ajax请求时显示loading界面。 vue-resource插件具有以下特点：体积小vue-resource非常小巧，在压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多。 支持主流的浏览器和Vue.js一样，vue-resource除了不支持IE 9以下的浏览器，其他主流的浏览器都支持。 支持Promise API和URI TemplatesPromise是ES6的特性，Promise的中文含义为“先知”，Promise对象用于异步计算。URI Templates表示URI模板，有些类似于ASP.NET MVC的路由模板。 支持拦截器拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。 关于vue-resource更详细的介绍:http://www.cnblogs.com/keepfool/p/5657065.html 获取数据 如图,Header组件里的商家数据，是通过异步请求后端的数据接口获得的，header组件就负责接受这样的数据并渲染 。在app.vue组件（header的父组件），通过发送一个AJAX请求去获取商家的相关数据，取回来的数据放进app.vue里的&lt;header&gt;标签,然后这些数据通过header组件里的prop属性设置一下后,数据就在header组件里,就可以调用这些数据来做我们想做的事情 父子组件间的通信组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模版中使用了组件 B 。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。然而，在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性。 在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。看看它们是怎么工作的。 使用 Prop 传递数据组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。prop 是父组件用来传递数据的一个自定义属性。子组件需要显式地用 props 选项声明 “prop”： 1234567Vue.component('child', &#123; // 声明 props props: ['message'], // 就像 data 一样，prop 可以用在模板内 // 同样也可以在 vm 实例中像 “this.message” 这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;) 然后向它传入一个普通字符串： 结果输出“hello”。 回到项目中来 首先我们需要给app.vue定义一个seller的对象：可以通过data()方法。在vue.js中，这个data属性是一个函数（可查看链接），因为组件是可以被复用的，如果定义一个对象然后修改某一个组件的话会影响另外的组件，所以这里定义成一个函数。这个函数return一个对象，对象里面有seller对象，先定为空，然后我们通过发送AJAX请求去拿到一个seller对象，然后send给它。这样就可以拿到seller对象的数据。 Vue.js社区有个第三方插件：vue-resource，用来处理一些前后端请求数据交互的。 示例： 12345678&#123; // GET /someUrl this.$http.get('/someUrl').then((response) =&gt; &#123; // success callback &#125;, (response) =&gt; &#123; // error callback &#125;);&#125; 同样的，需要在package.json添加它的依赖： 第三方插件import引用时需要注册，用Vue.use(vueResource)把这个注册。在main.js注册 然后回到app.vue，在这里我们需要通过一个vue.resource去发送一个AJAX请求，需要在什么时序去发起呢？ 我们知道每个vue实例化的时候都有一个生命周期，其中有个钩子叫created(). 关于钩子：https://segmentfault.com/q/1010000004335505 关于实例的生命周期：https://cn.vuejs.org/v2/guide/instance.html#实例生命周期 这是它的一个生命周期钩子函数，就是一个vue实例被生成后调用这个函数。一个vue实例被生成后还要绑定到某个html元素上，之后还要进行编译，然后再插入到document中。每一个阶段都会有一个钩子函数，方便开发者在不同阶段处理不同逻辑。 一般可以在created函数中调用ajax获取页面初始化所需的数据,如下图: 去chrome的network查看,看到请求已经发出去了 vue-resource就介绍完了，seller对象已经拿到，接下来就把seller对象传递给header组件，让header渲染即可。 这里还有一个坑!! Vue-resource 1.0的时候,右侧的response就能直接拿到seller字段 但是2.0时,resource封装的方法变了,需要response.body,才能拿到seller,不加body,只会拿到一个Object ##","categories":[],"tags":[]},{"title":"Vue2.0仿外卖APP（四）","slug":"web-app04","date":"2017-05-16T10:34:07.647Z","updated":"2017-05-16T14:25:16.451Z","comments":true,"path":"2017/05/16/web-app04/","link":"","permalink":"https://silkyer.github.io/2017/05/16/web-app04/","excerpt":"","text":"组建拆分先在static目录下引入reset.css 接着在index.html引入，并且设置移动端&lt;meta&gt;,viewport的 有时候由于eslint的检测功能,写js少一个冒号多一个空格都会频繁报错,这会让刚接触Vue或者对ES6不熟悉的人痛苦不堪,可以在上一节讲到的eslint相关配置处,把对应检测功能置零 如果不置零,下面这段代码就会报错: 所以要到eslintrc.js去设置 现在的App.vue如下： 然后我们编写组件来替换那三个区块。 创建header组件 将header引入到App.vue里面(注册)： Components后面要有空格。 这里还要安装一个stylus-loader依赖，不然会报错。 这里提供一个依赖包的安装方法：到package.json，在里面添加所需要的最新版本的包，然后再cnpm install ，这样就可以添加到node_modules里面了，运行cnpm run dev。 基本的组件结构如下: Vue-router因为在单页应用中，内容区块有三部分，所以这时候要用到路由vue-router http://router.vuejs.org/zh-cn/installation.html 同样通过package.json来安装。 vue-router的用法：http://router.vuejs.org/zh-cn/essentials/getting-started.html 可以参考下面两个链接: 官网的写法：http://router.vuejs.org/zh-cn/essentials/getting-started.html 参考：https://segmentfault.com/q/1010000007929093/a-1020000007929260(PS: 链接都是个人觉得在遇到困难时很好的解决思路,所以放上来供大家参考) 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)。在通过use()这个方法，相当于安装插件。 参照官网给的vue-router的过程： 12345678910111213141516171819202122232425262728293031// 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)// 1. 定义（路由）组件。// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;// 2. 定义路由// 每个路由应该映射一个组件。 其中\"component\" 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;]// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;)// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app')// 现在，应用已经启动了！ 所以,main.js是这样的: 1像素border实现border-bottom: 1px solid rgba(7, 17, 27, 0.1) 直接在.tab加这句话可以实现，但是在移动端看到的就不是这样的，因为手机端有个dpr的概念,电脑设置的1px不代表所有手机里面显示的都是1px:http://mobile.51cto.com/web-484304.htm 总的来说就是: 想要在dpr=2的设备下显示1px,对于css而言,可认为border: 0.5px,因为这是retina下(dpr=2)下能显示的最小单位。 然而，无奈并不是所有手机浏览器都能识别border: 0.5px;，ios7以下，android等其他系统里，0.5px会被当成为0px处理，那么如何实现这0.5px呢？ 由于项目中多处用到border1px,所以单独拿出来放到一个通用文件里: mixin.styl 这只是通用文件,真正实现1px,关键是检测出设备dpr,从而进行缩放 没错就是媒体查询@media 把检测dpr这个功能单独隔离出一个base.styl 所以为了使用border1px,则需要在使用的那个组件,同时@import (base.styl)和(mixin.styl),为了简洁,我们把这些需要单独引入的css文件,再放入一个总的styl文件: index.styl 至此,每一个需要用到border1px的地方,只需要: 总结一像素的实现：伪类+缩放（用一个class） 这样基本框架已经搭建好了，接下来就来开发组件。","categories":[],"tags":[]},{"title":"Vue2.0仿外卖APP（三）","slug":"web-app03","date":"2017-05-16T10:12:00.256Z","updated":"2017-05-16T10:30:51.074Z","comments":true,"path":"2017/05/16/web-app03/","link":"","permalink":"https://silkyer.github.io/2017/05/16/web-app03/","excerpt":"","text":"APP结构如下: 项目资源准备准备项目的各种图片资源等等 注意：在webpack可以不用css sprite，直接用单张图片，因为它会帮忙打包。 还有SVG图片，放大之后不会影响质量，在移动端开发中，通常会把色彩单一的图片做成SVG图片。这些不是直接用，利用一些工具去把这些SVG图片去转化成一个叫图标字体的文件，就可以在CSS引用了。 图标字体制作在项目开发前期，我们需要将设计师给的一些图片制作成字体图标 用一个叫IcoMoon的工具（https://icomoon.io/），它本身有的图标可以查看IcoMoon App，要用自定义图标的话可以在IcoMoon App里面点击Import Icons，将所有的SVG图片导入，就可以下载使用了。（里面的Get Code可以查看使用方法）。在下载之前可以点击左上角的preferences，设置一下名称：sell-icon 项目目录设计所有代码都在src文件目录下 入口文件main.js； 整个页面的vue实例文件App.vue； components：存放我们的组件文件，但我们不会像hello.vue一样直接放在里面，我们会多件一个子目录，像这样： 这样做是因为一个vue组件除了它的.vue文件以外，还可能包含一个图片相关资源等等。之前说过，组件一个很重要的设计原则就是就近维护，把一个组件相关资源都放在一个目录下。 还要创建一个common目录，包好一个公共的模块和资源，再在它其中添加三个子目录。 在这儿项目中，我们使用的css预处理器是stylus。 结构如下图： 并且将图标字体生成的style.css添加到stylus目录下，并改名为icon.styl，并改为stylus语法：把括号和分号去掉。 把asset目录删掉。 mock数据（模拟后台数据）作为前端经常需要模拟后台数据，我们称之为mock。 http://blog.csdn.net/sysuzjz/article/details/50317531 mock 的真正意义在于简化测试环境。假如你现在要测试一个dao，但是你有不想构建数据库环境就可以用mock模拟数据库的返回结果。 数据来源：data.json 我们模拟的数据请求就是从这里面读取数据，接下来就来编写这些接口。 打开build目录-dev-server.js（就是我们开发的webpack打包的一个入口文件），打开之后使用express这个框架去指一个nodeserver，我们也可以用express-router来编写这些接口请求。 先拿到这些数据(data.json)：1234var appData = require('../data.json');var seller = appData.seller;var goods = appData.goods;var ratings = appData.ratings; 编写路由，并编写接口：12345678910111213141516171819202122var apiRoutes = express.Router();apiRoutes.get('/seller', function (req, res) &#123; res.json(&#123; errno: 0, data: seller &#125;);&#125;);apiRoutes.get('/goods', function (req, res) &#123; res.json(&#123; errno: 0, data: goods &#125;);&#125;);apiRoutes.get('/ratings', function (req, res) &#123; res.json(&#123; errno: 0, data: ratings &#125;);&#125;); 要在express使用它，我们需要调用express的变量app： 1app.use('/api', apiRoutes); 这样我们就可以直接通过/goods来获取数据了。 完整的dev-server.js： 写完后要重新运行cnpm run dev，因为我们改的是node文件，然后http://localhost:8080/api/seller,如果能获取下面显示的数据,则代表数据获取成功","categories":[],"tags":[]},{"title":"Vue2.0仿外卖APP（二）","slug":"web-app02","date":"2017-05-16T06:21:07.692Z","updated":"2017-05-16T10:07:46.236Z","comments":true,"path":"2017/05/16/web-app02/","link":"","permalink":"https://silkyer.github.io/2017/05/16/web-app02/","excerpt":"","text":"Vue-cli开启vue.js项目github地址: https://github.com/vuejs/vue-cli Vue.js开发利器vue-cli，是vue的脚手架工具。 在工地上，脚手架是工人搭建好的架子，能够帮助工人们作业；在技术圈，脚手架就是来帮助我们编写好基础的代码的工具。Vue-cli就是帮助我们写好vue.js基础代码的工具。 使用Vue.js，当你构建一个原型的时候，你所需要做的通常就是通过 &lt;script&gt; 把Vue.js引入进来，然后就完事了。但是真实情况往往不是这样的。当我们真正开发一个应用的时候，我们不可避免的会用到一大堆的工具，模块化、预处理器、热模块加载、代码校验和测试。这些工具对于一个需要长期维护的大型应用是必须的，但是项目初始化将会是让人痛苦的事情。这就是为什么我们做了 vue-cli ，让一个简单的命令行工具来帮助你快速的构建一个拥有强大构建能力的Vue.js项目。 可以说，它仅仅是为了初始化。 使用方法(以下操作均在终端(git)进行):// 安装vue-cli：Vue-cli是一个node包，所以要通过cnpm去安装 cnpm install -g vue-cli // 使用vue-cli初始化项目 vue init webpack my-project // 进入到目录 cd my-project // 安装依赖，生成node_modules目录 cnpm install // 开始运行 cnpm run dev 上面的这些命令会从 vuejs-templates 拉取模板并安装，然后用npm安装依赖，最后你只需要用个npm脚本启动就能开始开发了。 使用vue-cli初始化项目vue init webpack my-project的语法为: vue init Template-name就是模板名称：模板就是安装成功后给你自动生成的一个代码模板。 这些官方的模板存在的意义在于提供强大的项目构建能力，以至于用户可以尽可能快速的进行开发。然而能否真正的发挥作用还在于你如何组织你的代码和你使用的其他库。 所有的官方模板都可以在 vuejs-templates organization找到。如果有一个新的模板放在了这里，你可以直接就用 vue init &lt;template-name&gt; &lt;project-name&gt;使用。你也可以运行 vue list 命令来看看现在有哪些官方模板是现在可用的。 模板分为三类官方模板，就是我们通常用的 webpack与webpack-simple两种的区别在于webpack-simple 没有包括Eslint 检查功能等等功能，普通项目基本用webpack-simple 就足够了. 自定义模板 vue init username/repo my-project 从自己的仓库去安装。 无论是官方模板还是自定义模板，它都是去GitHub repo里面安装的。比如webpack模板： https://github.com/vuejs-templates/webpack 这就是webpack仓库的模板地址： 点进去template这个目录： 这部分就是我们最终安装后会生成的代码。 Project-name：是安装后会在当前目录下生产一个名为project-name的一个目录，然后把它的模板、所有代码都自动生成到这个目录下。 无处不在的Vue组件每一个模板都有自己的作用：基础版本用于快速构建原型，高级版本用于正式开发。这些模板有许多共同的功能，如都支持 *.vue 组件。这意味着任何第三方的Vue组件都可以随意使用，并且可以轻而易举的发布在npm上 备注ESLint：http://eslint.org/docs/user-guide/configuring。在团队协作中，为避免低级 Bug、产出风格统一的代码，会预先制定编码规范。使用 Lint 工具和代码风格检测工具，则可以辅助编码规范执行，有效控制代码质量。 http://www.tuicool.com/articles/7JZZJzn Karma+Mocha：https://github.com/karma-runner/karma-mocha。单元测试 mocha是一个js的测试框架。Karma是一个驱动测试的Runner。也就是说，karma为测试框架准备运行环境，可以让这些测试在真正的浏览器里运行。 Nightwatch：http://nightwatchjs.org/。验收测试框架，使用Selenium WebDriver API以将Web应用测试自动化。它提供了简单的语法，支持使用JavaScript和CSS选择器，来编写运行在Selenium服务器上的端到端测试。 关于生成项目文件的介绍 以下内容选自: http://blog.csdn.net/hongchh/article/details/55113751 build目录和config目录：都是与webpack的配置相关。 node_modules目录：npm install安装的依赖代码库 src目录：存放项目源码 statis目录：存放一些第三方静态资源的。可以看到它里面只有一个.gitkeep文件，它的作用是当这个目录为空也可以把这个项目提交到git代码仓库里。因为通常如果你创建一个空目录，git会忽略掉这个目录，它是不会提交到仓库里的。 .babelrc文件： 它是babel的一些配置。因为我们的代码都是ES6，而大部分浏览器都是还不支持的。所以通常我们的做法是将ES6通过babel编译成ES5，而.babelrc就是babel编译的一些配置。其中presets表示预设，[“es2015”, “stage-2”]表示babel转换预先需要安装的插件。我们可以在node_modules里面可以看到这两个插件。 &quot;plugins&quot;: [&quot;transform-runtime&quot;]：把ES6的方法做转换。 .editorconfig文件：编辑器的配置 分别是编码、缩进风格、缩进大小、换行符的风格、文件末尾插入新行、自动移除多余空格。 .eslintignore文件：忽略语法检查的目录文件{% image http://opolpcrco.bkt.clouddn.com/17-5-16/79534917-file_1494917086240_24e.png '' '' %}表示不会对build目录下和config目录下中的js文件做ES语法检查。 .eslintrc.js文件：Eslint的配置文件 在上图中extends: ‘standard’：表示继承一个标准的规则，可以在这里看到：https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style都是预先定义好的规则。 我们也可以通过rules对一些具体的规则做修改。 比如： 这里就修改了三个规则。配置成0就是不想要之前定义好的规则。 no-debugger：做一个判断，如果是开发环境就可以debugger，是生产环境就不能，因为生产环境下debugger是非常危险的。 .gitignore文件： 就是git仓库去忽略掉这些文件或者目录，不会提交到代码里面。 Index.html文件：就是我们的入口html文件 没有css，js文件，因为我们引用的资源会在我们的项目编译过程中自动插入到这个html文件中。 Package.json文件：项目的配置文件，用来描述一个项目。 运行”npm run dev”的时候执行的是build/dev-server.js文件，运行”npm run build”的时候执行（用来执行发布的）的是build/build.js文件，下面我们可以从这两个文件开始进行代码阅读分析。 Readme文件：项目的描述文件。 至此,Vue-cli初始化的文件就全部介绍完了 项目运行上面介绍了目录里的文件,那这些文件是怎么执行的呢 先来看它的入口文件index.html 入口js文件是main.js 依赖了两个vue库中的Vue、App.vue中对的App。 接着实例化一个Vue的实例，element挂载到”#app”上；模板是App；然后再用components注册一个当前App的插件，ES6的简写。也就是这个实例依赖App这个组件。 App.vue组件： 图中,用了一个&lt;hello&gt;标签,其实就是vue-cli初始化后的首页:Hello,Vue同时也可以看到,注册了hello,才能以&lt;hello&gt;这样在HTML页面中使用 (这是页面请求到的文件资源) app.js：打包后生成的代码；没有css，那时因为webpack在打包的时候也把css打包到js里面了。 可以看到：app.js接近1m，这么大是因为我们把那些ES6语法在运行时做一个解析。 所以接下来我们聊聊webpack webpack打包Webpack：当前最火的前端构建工具。http://webpack.github.io/ Webpack的功能：把各种各样的前端资源编译打包，最终输出css,图片和js。 Webpack的配置很复杂,vue-cli已经帮我们完成了95%的配置工作 总结起来就是: 当文档最终生成一个app.js时，源码中并没有这个文件，这个就是因为webpack的编译,打包 npm run dev 到底是什么?我们都知道,想运行一个Vue-cli初始化好的文件,预览效果,需要执行npm run dev ,那过程中到底发生了什么? npm run dev其实就是执行了”node build/dev-server.js”这个命令，运行了build目录下的dev-server.js文件 这个文件首先是有各种依赖： 由上至下的语句分别: Path就是node.js提供的API，提供一些文件路径操作的方法； Express是node.js的一个框架，这里用它去启动一个webserver； Webpack就是核心编译工具，直接用node.js提供的API，而不用全局的webpack； proxyMiddleware就是HTTP代理的一个中间件，可以代理和转发API ; WebpackConfig就是webpack的相关配置，这里由于是一个开发时的配置，所以它是依赖webpack.dev.conf。 看一下这个配置文件webpack.dev.conf： 除了刚刚提到的一些依赖，还有依赖一个webpack-merge，就是用来合并配置文件的； Utils就是工具方法； baseWebpackConfig也是一个webpack配置文件，它是被开发时的配置文件和运行时的配置文件所共享的； HtmlWebpackPlugin就是webpack提供的一个操作HTML文件的一个插件。 Webpack.base.conf.js文件：定义webpack一些基础配置 Webpack.base.conf.js文件里面又有什么呢? projectRoot定义了当前项目的根目录； Module.exports = {这里面就是webpack的基本配置 entry：一个入口配置。app: ‘./src/main.js’表示webpack编译的入口js文件 Output：输出的配置。path是路径；filename输出的文件名名称 Resolve：就是代码中request、import的一些相关配置。Extensions自动补全文件后缀名；fallback指向node_modules这个模块，也就是说当我们在前端request模块找不到的时候就可以在node_modules里面找；alias提供一些别名，也就是request路径中可以通过别名缩短书写。 resolveLoader：里面的fallback跟上面类似。 Module：preLoaders、loaders类似，对某种类型的文献应用某一个loader去做处理，webpack编译阶段就是利用各种loader对各种文件做编译。不同的文件利用不同的loader做处理。 Eslint：formatter当eslint检查到错误的时候会有好地提示一个信息并且提供链接查看错误原因。 Vue： 与css有关，utils里面 }","categories":[],"tags":[]},{"title":"Vue一些知识点","slug":"Vue一些知识点","date":"2017-05-16T06:14:01.965Z","updated":"2017-05-16T06:19:25.989Z","comments":true,"path":"2017/05/16/Vue一些知识点/","link":"","permalink":"https://silkyer.github.io/2017/05/16/Vue一些知识点/","excerpt":"","text":"1、 使用组件时，大多数可以传入到 Vue 构造器中的选项可以在注册组件时使用，有一个例外： data 必须是函数。 实际上，如果你使用的不是函数，那么 Vue 会在控制台发出警告，告诉你在组件中 data 必须是一个函数。 下面的例子会让所有的组件都同时发生变化 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"example-2\"&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt;&lt;/div&gt;&lt;script&gt;var data = &#123; counter: 0 &#125;Vue.component('simple-counter', &#123; template: '&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', // data 是一个函数，因此 Vue 不会警告， // 但是我们为每一个组件返回了同一个对象引用 data: function () &#123; return data &#125;&#125;)new Vue(&#123; el: '#example-2'&#125;)&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 由于这三个组件共享了同一个 data ， 因此增加一个 counter 会影响所有组件！我们可以通过为每个组件返回新的 data 对象来解决这个问题： 12345data: function () &#123; return &#123; counter: 0 &#125;&#125; https://cn.vuejs.org/v2/guide/components.html#data-必须是函数https://segmentfault.com/q/1010000007910818?_ea=1490198","categories":[],"tags":[]},{"title":"Vue2.0仿外卖APP（一）","slug":"web-app01","date":"2017-05-15T15:19:24.724Z","updated":"2017-05-16T03:59:06.325Z","comments":true,"path":"2017/05/15/web-app01/","link":"","permalink":"https://silkyer.github.io/2017/05/15/web-app01/","excerpt":"","text":"最近在学习慕课网的课程：用vue.js做一个仿饿了么外卖APP的项目，现在也把流程啊什么的暂时先整理一下在这个博客上面。 当然，这个过程会有点长，不过确实能学到很多东西。 话不多说，马上开始吧。 注：当我们把用vue-cli脚手架搭建成的vue项目复制到其他地方时，要把node_modules目录删除，不然在其他地方无法执行cnpm run dev，这其中设计到路径的问题。删除之后要重新cnpm install。 https://segmentfault.com/q/1010000006912664 https://www.zhihu.com/question/41409670?sort=created 1.项目介绍选用当前最火的MVVM框架作为这个项目的技术栈MVVM架构： View和model通过viewModel来通信，但数据发生变化，viewmodel能够观察到这种数据的变化，然后通知到对应的视图做自动更新；当用户操作view视图，viewModel也能监听到视图的变化，然后通知数据做改动，实现了数据的双向绑定。 应用场景： 针对具有复杂交互逻辑的前端应用； 它可以提供基础的架构抽象； 可以通过AJAX数据持久化，保证前端用户体验 好处： 当前端和数据做一些操作的时候，可以通过AJAX请求对后端做数据持久化，不需要刷新整个页面，只需要改动DOM里需要改动的那部分数据。特别是移动端应用场景，刷新页面太昂贵，会重新加载很多资源，虽然有些会被缓存，但是页面的DOM,JS,CSS都会被页面重新解析一遍，因此移动端页面通常会做出SPA单页应用。 该项目只提取饿了么其中一个模块–商家模块进行开发 项目开发的一个完整流程项目的需求分析–脚手架工具–数据mock–架构设计–代码编写–自测–编译打包等方面完全简讲述开发一个web的全流程，更好地了解一个项目从0到1的过程。 所需技术：项目完整的开发流程；组件化、模块化的开发模式；使用Vue-cli脚手架初始化Vue.js项目；webpack的打包原理；模拟json后端数据，前后端分离开发；es6+eslint的开发方式。 第三方组件：使用stylus编写模块化的CSS；使用vue-router开发单页应用；使用vue-resource与后端数据交互；在Vue.js框架里和第三方JS插件交互。 关于Vue的数据驱动思想在数据驱动的思想里，数据驱动DOM变化，DOM是数据的一种自然映射。 如果没有MVVM框架，数据和视图是如何交互的？ 比如通过AJAX从后端获取数据，会让视图改变，通过手动触发DOM的改变；再比如我们通过前端交互改变一些数据，为了让视图也发生变化，仍然需要通过手动触发进行DOM改变。手动改变DOM不仅繁琐，还容易出错。用了vue之后就可以省去操作DOM变化的步骤了。 在vue.js中，可以通过directives指令去对DOM做一层封装，当数据发生变化，会通知指令去修改对应的DOM。 Vue.js还会对操作做监听，当我们修改视图的时候，vue.js监听到这些变化，从而改变数据。 (↑上面两幅图红色区域代表正在执行该逻辑)这样就实现了数据的双向绑定。 vue.js数据响应的原理vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 思路整理 已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一，如果不熟悉defineProperty，猛戳→这里 整理了一下，要实现mvvm的双向绑定，就必须要实现以下几点：1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图4、mvvm入口函数，整合以上三者 详情可查看: 剖析Vue原理&amp;实现双向绑定MVVM (先把app做出来,回头来研究) 关于vue组件化的思想目的：拓展HTML元素，封装可重用代码 如下图：左侧是一个页面，被拆分成小的区块，每个区块对应一个组件，组件可以嵌套，最终组合成为一个完整页面。 在vue.js中，每个组件都对应一个viewModel，最终生成一个viewModel的树： 组件化讲解一个简单的HTML页面，以此为基础： 12345678910111213141516171819&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;揭开Vue组件的神秘面纱&lt;/title&gt; &lt;/head&gt; &lt;body&gt; //这中间就是实例挂载点的实例边界 &lt;div id=\"vueInstance\"&gt;&lt;/div&gt; &lt;script src=\"http://cdn.jsdelivr.net/vue/1.0.16/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; // 创建一个新的Vue实例，并设置挂载点 var V = new Vue(&#123; el : '#vueInstance' &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在Vue中，可以使用Vue.component()来创建和注册你的组件，这个构造器有两个参数：组件的名字；包含组件参数的对象。 接下来注册一个组件。创建并传入两个参数：组件的名字:’mine’；包含组件参数的对象:这个对象包含一个属性’template’。 123Vue.component('mine',&#123; template : '&lt;p&gt;My name is Appian.&lt;/p&gt;'&#125;) 现在你已经有了自己的一个组件了，你可以在你的应用的任何地方使用它。只要你调用它的唯一标识(就是组件名字)，并用普通html标签的格式来书写，比如，组件上注册的内容就会在你的自定义标签的地方插入。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue组件&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"vueInstance\"&gt; &lt;mine&gt;&lt;/mine&gt; &lt;mine&gt;&lt;/mine&gt; &lt;mine&gt;&lt;/mine&gt; &lt;/div&gt; &lt;script src=\"http://cdn.jsdelivr.net/vue/1.0.16/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('mine',&#123; //这里就是注册的内容 template : '&lt;p&gt;My name is Vue.&lt;/p&gt;' &#125;); // 创建一个新的Vue实例，并设置挂载点 var V = new Vue(&#123; el : '#vueInstance' &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用template标签处理复杂组件如果总是在vue.component()构造器里写html代码，复杂页面就不得了了。为了避免上面的这种情况，所以我们可以用template标签（注意属性和标签是不一样的）来达到我们的目的。我们可以在页面的任何地方，定义template标签，并在template标签内，写好我们的模板。 因为template标签在页面加载的时候不会渲染出来，只有在我们需要它的时候，这个标签内的内容才会被渲染出来。所以，你可以把template标签放在任何地方，并给它一个id，以便在组件注册的时候能够找到模板。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue组件&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"vueInstance\"&gt; &lt;mine&gt;&lt;/mine&gt; &lt;/div&gt; &lt;template id=\"myVue\"&gt; &lt;p&gt;i am vue&lt;/p&gt; &lt;p&gt;welcome!&lt;/p&gt; &lt;/template&gt; &lt;script src=\"http://cdn.jsdelivr.net/vue/1.0.16/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('mine',&#123; //这里就是注册的内容 template : '#myVue' &#125;); // 创建一个新的Vue实例，并设置挂载点 var V = new Vue(&#123; el : '#vueInstance' &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过props向组件中传递数据Vue是处理父组件向子组件中传递数据是通过props。 1234Vue.component('mine',&#123; template : '&lt;p&gt;Appian is from &#123;&#123; city &#125;&#125;.&lt;/p&gt;', props : ['city']&#125;); props可以是数组，也可以是对象。 那父组件那里又是怎么指派字段给子组件的呢？ 只需要在对应的标签内写下属性就好 1&lt;mine city=\"welcome\"&gt;&lt;/mine&gt;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-05-13T06:07:47.892Z","updated":"2017-05-13T06:07:47.925Z","comments":true,"path":"2017/05/13/hello-world/","link":"","permalink":"https://silkyer.github.io/2017/05/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}