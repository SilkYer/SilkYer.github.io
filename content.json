{"meta":{"title":"SilkYer's Blog","subtitle":"Write the code , Change the world","description":null,"author":"SilkYer","url":"https://silkyer.github.io"},"pages":[],"posts":[{"title":"没得加班 伐开心","slug":"0529summary","date":"2017-05-29T14:16:50.916Z","updated":"2017-05-29T16:02:16.179Z","comments":true,"path":"2017/05/29/0529summary/","link":"","permalink":"https://silkyer.github.io/2017/05/29/0529summary/","excerpt":"","text":"打算加到九点半 突然被家里人叫回去还以为有什么事 一个多小时到家了发现 原来只是希望我能回来休息一会.. 我又哪敢跟他们说 是担心自己项目做不完 说了也白操心 废话不多说总结一波 element.ui例子如下: 实现点1 四消失,点2 四出现的效果 曾经使用element.ui框架 用&lt;el-radio-group&gt;实现选项框 然而有两个问题: 1、&lt;el-radio&gt;的源码实际上除了外部一个&lt;div&gt;外还封装多了一层&lt;slot&gt;在里面,所以在&lt;el-radio&gt;上绑定点击事件,会出现点击两次的情况(具体如何在源码层解决这个问题..尝试过用if(!event_constructed){},然而要么一次不点击要么点击两次 很头疼 后来也试过阻止冒泡也没用(貌似这个两次点击不是因为冒泡?)日后有空再说= = 当下以实现业务逻辑为主 2、在&lt;el-radio&gt;内无法绑定v-show,需要额外包一个div,在新div内使用v-show,这样就导致&lt;el-radio&gt;一些margin和其他elemetn的radio有不同 要修改样式 太麻烦了 这两点让我直接放弃了element.ui,乖乖用回bootstrap (虽然之前从没用过bootstrap.. bootstrap用的是label标签包input,多选和单选框只需要在type=checkbox/radio中选择就好,没有ele封装的那么多,但是点击事件依然要放在input层,放在label层依然会出现两次点击噢~ 第一次接手crm的issue好激动!!!第一次被指派assignee,take over gitlab上的issue,虽然只是超级简单的改模板..不过也对找路径更加熟练了 总结出一个方法： 如果url上的地址 找不到对应的views 那就去module里面 输入中文 找到相应路由 里面就有详细路径 如果想查看数据的那个view刚好没数据 可以F12去response里拿相应的数据,找到你想要塞数据的弄个view对应的controller,在ng封装的ajax里面把假数据放进去 这样就可以达到效果 git remote XXXX not have locally说的是 远端和本地的版本不一致被老大告知 git pull –rebase即可可是阮一峰上面说 用rebase后面还要加语句： 懵逼了 总之，以后出现这种远端和本地版本不一致 使用git pull –rebase就好 pls commit before switch 提示说，怕你丢失文件，先缓存一下 所以执行： git stash git pull 之后就可以切换分支啦: git checkout -b dev origin/dev P.S : git和webpack..真是把我操 碎了心","categories":[],"tags":[]},{"title":"工作总结","slug":"0525summary","date":"2017-05-25T14:13:51.281Z","updated":"2017-05-29T14:15:58.556Z","comments":true,"path":"2017/05/25/0525summary/","link":"","permalink":"https://silkyer.github.io/2017/05/25/0525summary/","excerpt":"","text":"关于git2017-5-25 20:20:40 特么 终于git上去了 今天的git出现了各种错误 搞了半天 总结如下： 个人情况是：别人已经给你开好了仓库，所以只需要想办法把本地文件上传到仓库就好 （通过SSH上传下载） 1、复制地址 然后去你想要放置的本地仓库目录 右键 点出git bash 2、git add . (后面一定要加上 . ) 3、git commit ‘’(引号里面写上bio,就是github提交代码前的标注) 4、git push (由于我用的是别人的电脑,SSH和git的username和user.email全都绑定过上一个人的,要重新绑成我自己的 这些东西也折腾了不少时间 坐在办公室再搞这些工具没有有效输出的真的好心累) 关于工作效率确定好任务 以为可以专心撸代码 结果有各种各样的事情: 由于用公司gitlab协作,之前我用github客户端.相当于重新学一个东西,刚刚上面的push和pull代码 折腾了一个下午,麻烦了三位组员跑来跑去才解决 其次 vue-cli脚手架搭的目录和公司代码规范严重不符需要重新规划 目录一变 webpack就要重新配置 以前从来没看过webpack的我直接懵比了 目录一遍 项目甚至运行不起来(不过找到了不用cli搭建的教程了 明天撸起来) 希望妈妈的检查报告不会有任何问题","categories":[],"tags":[]},{"title":"CSS 选择器","slug":"CSS-selector","date":"2017-05-18T10:43:13.086Z","updated":"2017-05-18T16:17:12.719Z","comments":true,"path":"2017/05/18/CSS-selector/","link":"","permalink":"https://silkyer.github.io/2017/05/18/CSS-selector/","excerpt":"","text":"CSS 选择器种类繁多,其中几个长得还比较像,如果有的属性用的不多,一会就忘记了,特别是CSS3中的:nth选择器,那么从现在开始从头一起来看看CSS选择器的运用。 CSS是一种用于屏幕上渲染html，xml等一种语言，CSS主要是在相应的元素中应用样式，来渲染相对应用的元素，那么这样我们选择相应的元素就很重要了，如何选择对应的元素，此时就需要我们所说的选择器。选择器主要是用来确定html的树形结构中的DOM元素节点。我把CSS选择器分开成三部分，第一部分是我们常用的部分，我把他叫做基本选择器；第二部分我把他称作是属性选择器，第三部分我把他称作伪类选择器，这一部分也是最难理解和掌握的部分，先来看第一部分——基本选择器。 为了更好的说明问题，先创建一个简单的DOM结构，如下： 加些CSS,效果如下所示： 基本选择器通配符选择器（＊）我们平常不加reset.css的时候 都会加上 1234 * &#123; margin: 0; padding: 0;&#125; 所有浏览器支持通配符选择器。 元素选择器(E)元素选择器，是css选择器中最常见而且最基本的选择器。元素选择器其实就是文档的元素，如html,body,p,div等等，比如我们这个demo：中元素包括了div,ul,li等。 所有浏览器支持元素选择器(E)。 类选择器（.className）类选择器是以一独立于文档元素的方式来指定样式，使用类选择器之前需要在html元素上定义类名，换句话说需要保证类名在html标记中存在，这样才能选择类. 类选择器还可以结合元素选择器来使用，比如说，你文档中有好多个元素使用了类名“items”，但你只想在p元素这个类名上修改样式，那么你可以这样进行选择并加上相应的样式： 上面代码只会对p元素并且是其有一个类名叫“items”。不符合这两个条件的都不会被选择。 所有浏览器都支持类选择器，但多类选择器（.className1.className2）不被ie6支持。 id选择器（#ID）ID选择器和上面说的类选择器是很相似的，在使用ID选择器之前也需要先在html文档中加注ID名称，这样在样式选择器中才能找到相对应的元素，不同的是ID选择器是一个页面中唯一的值，我们在类使用时是在相对应的类名前加上一个“.”号（.className）而id选择器是在名称前使用”#”如(#id) 所有浏览器都支持ID选择器。 那么什么时候采用id命名？什么时候采用类命名呢？我个人认为就是关键的一点就是具有唯一性使用id选择器；公用的，类似的使用类选择器。使用这两个选择器时，最好区别大小写。 后代选择器（Ｅ Ｆ）后代选择器也被称作包含选择器,所起作用就是可以选择某元素的后代元素，比如说:E F，前面E为祖先元素，Ｆ为后代元素，所表达的意思就是选择了Ｅ元素的所有后代Ｆ元素，请注意他们之间需要一个空格隔开。这里Ｆ不管是E元素的子元素或者是孙元素或者是更深层次的关系，都将被选中，换句话说，不论Ｆ在Ｅ中有多少层关系，都将被选中 所有浏览器都支的后代选择器。 子元素选择器(E&gt;F)子元素选择器只能选择某元素的子元素，其中E为父元素，而F为子元素，其中E&gt;F所表示的是选择了Ｅ元素下的所有子元素Ｆ。这和后代选择器（Ｅ Ｆ）不一样，在后代选择器中Ｆ是Ｅ的后代元素，而子元素选择器Ｅ &gt; F，其中Ｆ仅仅是Ｅ的子元素而已. IE6不支持子元素选择器。 相邻兄弟元素选择器(E + F)相邻兄弟选择器可以选择紧接在另一元素后的元素，而且他们具有一个相同的父元素，换句话说，EF两元素具有一个相同的父元素，而且Ｆ元素在Ｅ元素后面，而且相邻，这样我们就可以使用相邻兄弟元素选择器来选择Ｆ元素。 上面代码表示选择li的相邻元素li，我们这里一共有十个li，那么上面的代码选择了从第2个li到 10 个li，一共九个，请看效果： 因为上面的li+li其中第二li是第一li的相邻元素，第三个又是第二个相邻元素，因此第三个也被选择，依此类推，所以后面九个li都被选中了，如果我们换过一种方式来看，可能会更好的理解一点： 按照前面所讲的知识，这句代码很明显选择了li.active后面相邻的li元素，注意了和li.active后面相邻的元素仅只有一个的。如图： IE6不支持这个选择器 通用兄弟选择器（Ｅ ~ Ｆ）通用兄弟元素选择器是CSS3新增加一种选择器，这种选择器将选择某元素后面的所有兄弟元素，他们也和相邻兄弟元素类似，需要在同一个父元素之中，换句话说，E和F元素是属于同一父元素之内，并且F元素在Ｅ元素之后，那么E ~ F 选择器将选择中所有Ｅ元素后面的Ｆ元素。比如下面的代码： 上面的代码所表示的是，选择中了li.active 元素后面的所有兄弟元素li,如图所示： 通用兄弟选择器和相邻兄弟选择器极其相似，只不过，相邻兄弟选择器仅选择是元素的仅与其相邻的后面元素（选中的仅一个元素）；而通用兄弟元素选择器，选中的是元素相邻的后面兄弟元素，这样说起来可能会有迷糊，大家可以仔细看看其相邻兄弟的效果图。 IE6不支持这种选择器的用法。 群组选择器（selector1,selector2,…,selectorN）群组选择器是将具有相同样式的元素分组在一起，每个选择器之间使用逗号“，”隔开，如上面所示selector1,selector2,…,selectorN。这个逗号告诉浏览器，规则中包含多个不同的选择器，如果不有这个逗号，那么所表达的意就完全不同了，省去逗号就成了我们前面所说的后代选择器，这一点大家在使用中千万要小心加小心。我们来看一个简单的例子： 因为li.first和li.last具有相同的样式效果，所以我们把他们写到一个组里来： 所有浏览器都支持群组选择器。 属性选择器属性选择器早在CSS2中就被引入了，其主要作用就是对带有指定属性的HTML 元素设置样式。使用CSS3属性选择器，你可以只指定元素的某个属性，或者你还可以同时指定元素的某个属性和其对应的属性值。CSS3的属性选择器主要包括以下几种： E[attr]：只使用属性名，但没有确定任何属性值；E[attr=&quot;value&quot;]：指定属性名，并指定了该属性的属性值；E[attr~=&quot;value&quot;]：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个value词，而且等号前面的“〜”不能不写；E[attr^=&quot;value&quot;]：指定了属性名，并且有属性值，属性值是以value开头的；E[attr$=&quot;value&quot;]：指定了属性名，并且有属性值，而且属性值是以value结束的；E[attr*=&quot;value&quot;]：指定了属性名，并且有属性值，而且属值中包含了value；E[attr|=&quot;value&quot;]：指定了属性名，并且属性值是value或者以“value-”开头的值（比如说zh-cn）; 为了更好的说明CSS3属性选择器的使用方法，我们把第一节的demo换成别的结构，如下所示： {% image http://opolpcrco.bkt.clouddn.com/17-5-18/30487575-file_1495114314759_12082.png '' '' %} 再加一点CSS美化后,下面就开始针对上面列出的每个属性选择器来，具体分析其使用方法。 E[attr]E[attr]属性选择器是CSS3属性选择器中最简单的一种。如果你希望选择有某个属性的元素，而不论这个属性值是什么，你就可以使用这个属性选择器，如： {% image http://opolpcrco.bkt.clouddn.com/17-5-18/18967267-file_1495114376981_4fe0.png '' '' %} 上面代码所表示的，选择了div.demo下所有带有id属性的a元素，并在这个元素上使用背景色为兰色，前景色为黄色，字体加粗的样式，对照上面的html，我们不难发现，只有第一个和最后一个链接使用了id属性，所以选中了这两个a元素，效果如下所示： {% image http://opolpcrco.bkt.clouddn.com/17-5-18/86927423-file_1495114576494_774e.png '' '' %} IE6不支持这个选择器。 Ｅ[attr=”value”]E[attr=”value”]选择器和E[attr]选择器，从字面上就能很清楚的理解出来，E[attr=”value”]是指定了属性值“value”，而E[attr]只是选择了有对应的属性，并没有明确指其对应的属性值”value”，这也是这两种选择器的最大区是之处。从而缩小了选择 围，更能精确选择自己需要的元素，在前面实例基础上我们进行一下简单的修改： {% image http://opolpcrco.bkt.clouddn.com/17-5-18/45776259-file_1495114609686_e6f6.png '' '' %} 和前面代码相比较，此处在id的属性基础上指定了相应的value值为“first”,这样一来我们选中的是div.demo中的a元素，并且这个元素有一个”id=”first””属性值，请看下在的效果图： {% image http://opolpcrco.bkt.clouddn.com/17-5-18/13169749-file_1495114725681_16d42.png '' '' %} E[attr=”value”]属性选择器也可以多个属性并写，进一步缩小选择范围 对于E[attr=”value”]这种属性值选择器有一点需要注意：属性和属性值必须完全匹配，特别是对于属性值是词列表的形式时，如： {% image http://opolpcrco.bkt.clouddn.com/17-5-18/74026612-file_1495114793214_1bcf.png '' '' %} 例如上面的代码，如果你写成： {% image http://opolpcrco.bkt.clouddn.com/17-5-18/6491914-file_1495114847841_18530.png '' '' %} 面的属性选择器并不会和上在的html匹配,因为他们的属性和属性值没有完全匹配，需要改成如下所示的代码，才能正确匹配： {% image http://opolpcrco.bkt.clouddn.com/17-5-18/17402346-file_1495114854197_11891.png '' '' %} IE6浏览器不支持这种选择器。 E[attr~=”value”]↑ 的例子中, .demo a[class=’links’] 识别不了class=&#39;links item&#39; 这样的词列表,那如何才能写一个词,却能识别整个列表呢？这时，E[attr~=”value”]就派上用场了 上面代码表示的是，div.demo下的a元素的title属性中，只要其属性值中含有”website”这个词就会被选择，回头看看我们的html，不难发现所有a元素中“2，6，7，8”这四个a元素的title中都含有,所以被选中，请看效果： IE6不支持E[attr~=”value”]属性选择器。 E[attr^=”value”]E[attr^=”value”]属性选择器，指的是选择attr属性值以“value”开头的所有元素，换句话说，选择的属性其以对应的属性值是以“value”开始的，一起来看个实例： 上面代码表示的是选择了以href属性，并且以”http://&quot;和&quot;mailto:&quot;开头的属性值的所有a元素，换过更简单一点的呢？只要a元素中的href属性值是以&quot;http://&quot;或&quot;mailto:&quot;开头的a元素都会以选中，那么下面大家请对照上面的html和下面的效果图，看看是不是那么一回事： IE6不支持E[attr^=”value”]选择器。 E[attr$=”value”]Ｅ[attr$=”value”]属性选择器刚好与E[attr^=”value”]选择器相反，E[attr$=”value”]表示的是选择attr属性值以”value”结尾的所有元素，换句话说就是选择元素attr属性，并且他的属性值是以value结尾的，这个运用在给你一些特殊的链接加背景图片很方便的，比如说给pdf,png,doc等不同文件加上不同icon，我们就可以使用这个属性来实现，如： 上面代码表示的是，选择div.demo中元素有href属性，并以png值结尾的a元素。（正如上面所说，只不过这里使用的是改变元素的背景色），效果如下： IE6不支持E[attr$=”value”]属性选择器。 E[attr*=”value”]E[attr*=”value”]属性选择器表示的是选择attr属性值中包含子串”value”的所有元素。也就是说，只要你所选择的属性，其属性值中有这个”value”值都将被选中，如： 上面代码表示的是：选择了div.demo中a元素，而a元素的title属性中只要有”site”就符合选择条件。效果如下： E[attr|=”value”]E[attr|=”value”]是属性选择器中的最后一种，在说这个选择器使用之前先提醒大家attr后面的是一个竖线“｜”而不是l，小心搞错了。E[attr|=”value”]被称作为特定属性选择器。这个选择器会选择attr属性值等于value或以value-开头的所有元素,我们来看个实例： 上面的代码会选中了div.demo中lang属性等于zh或以zh-开头的所有a元素，大家可以对照前面的html代友，其中”2,3,4,6”被选中，因为他们都有一个lang属性，并且他们的属性值都符合以”zh”或”zh-“开始的元素。具体效果如下： 所以这种属性选择器用来匹配以“女value-1”,”value-2”的属性是很方便的，比如说你页面中有很多图片，图片文件名都是以”figure-1”,”figure-2”这样的方式来命名的，那么使用这种选择器选中图片就很方便了，大家可以在本地尝试一下，这种属性选择器最常常用的地方是如上面的示例用来匹配语言。 IE6不支持E[attr|=”value”]选择器。 CSS预处理器作用前言如今网站的复杂度已经不可同日而语，原生 CSS 已经让开发者力不从心，预处理应运而生，以stylus为例,下面列举几个比较重要的功能： 文件切分页面越来越复杂，需要加载的 CSS 文件也越来越大，我们有必要把大文件切分开来，否则难以维护。传统的 CSS 文件切分方案基本上就是 CSS 原生的 @import 指令，或在 HTML 中加载多个 CSS 文件，这些方案通常不能满足性能要求。 CSS 预处理器扩展了 @import 指令的能力，通过编译环节将切分后的文件重新合并为一个大文件。这一方面解决了大文件不便维护的问题，另一方面也解决了一堆小文件在加载时的性能问题。 模块化把文件切分的思路再向前推进一步，就是 “模块化”。一个大的 CSS 文件在合理切分之后，所产生的这些小文件的相互关系应该是一个树形结构。 树形的根结节一般称作 “入口文件”，树形的其它节点一般称作 “模块文件”。入口文件通常会依赖多个模块文件，各个模块文件也可能会依赖其它更末端的模块，从而构成整个树形。 以下是一个简单的示例： 1234567891011entry.styl ├─ base.styl │ ├─ normalize.styl │ └─ reset.styl ├─ layout.styl │ ├─ header.styl │ │ └─ nav.styl │ └─ footer.styl ├─ section-foo.styl ├─ section-bar.styl └─ ... 如果你用过其它拥有模块机制的编程语言，应该已经深有体会，模块化是一种非常好的代码组织方式，是开发者设计代码结构的重要手段。模块可以很清晰地实现代码的分层、复用和依赖管理，让 CSS 的开发过程也能享受到现代程序开发的便利。 选择符嵌套选择符嵌套是文件内部的代码组织方式，它可以让一系列相关的规则呈现出层级关系。在以前，如果要达到这个目的，我们只能这样写： 123.nav &#123;margin: auto /* 水平居中 */; width: 1000px; color: #333;&#125; .nav li &#123;float: left /* 水平排列 */; width: 100px;&#125; .nav li a &#123;display: block; text-decoration: none;&#125; 这种写法需要我们手工维护缩进关系，当上级选择符发生变化时，所有相关的下级选择符都要修改；此外，把每条规则写成一行也不易阅读，为单条声明写注释也很尴尬（只能插在声明之间了）。 在 CSS 预处理语言中，嵌套语法可以很容易地表达出规则之间的层级关系，为单条声明写注释也很清晰易读： 12345678910.nav margin: auto // 水平居中 width: 1000px color: #333 li float: left // 水平排列 width: 100px a display: block text-decoration: none 变量在变更出现之前，CSS 中的所有属性值都是 “幻数”。你不知道这个值是怎么来的、它的什么样的意义。有了变量之后，我们就可以给这些 “幻数” 起个名字了，便于记忆、阅读和理解。 接下来我们会发现，当某个特定的值在多处用到时，变量就是一种简单而有效的抽象方式，可以把这种重复消灭掉，让你的代码更加 DRY。 我们来比较一下以下两段代码： 1234567891011/* 原生 CSS 代码 */strong &#123; color: #ff4466; font-weight: bold;&#125;/* ... */.notice &#123; color: #ff4466;&#125; 1234567891011// 用 Stylus 来写$color-primary = #ff4466strong color: $color-primary font-weight: bold/* ... */.notice color: $color-primary 你可能已经意识到了，变量让开发者更容易实现网站视觉风格的统一，也让 “换肤” 这样的需求变得更加轻松易行。 运算光有变量还是不够的，我们还需要有运算。如果说变量让值有了意义，那么运算则可以让值和值建立关联。有些属性的值其实跟其它属性的值是紧密相关的，CSS 语法无法表达这层关系；而在预处理语言中，我们可以用变量和表达式来呈现这种关系。 举个例子，我们需要让一个容器最多只显示三行文字，在以前我们通常是这样写的： 12345.wrapper &#123; overflow-y: hidden; line-height: 1.5; max-height: 4.5em; /* = 1.5 x 3 */&#125; 可以发现，我们只能用注释来表达 max-height 的值是怎么来的，而且注释中 3 这样的值也是幻数，还需要进一步解释。未来当行高或行数发生变化的时候， max-height 的值和注释中的算式也需要同步更新，维护起来很不方便。 接下来我们用预处理语言来改良一下： 1234567.wrapper $max-lines = 3 $line-height = 1.5 overflow-y: hidden line-height: $line-height max-height: unit($line-height * $max-lines, 'em') 乍一看，代码行数似乎变多了，但代码的意图却更加清楚了——不需要任何注释就把整件事情说清楚了。在后期维护时，只要修改那两个变量就可以了。 值得一提的是，这种写法还带来另一个好处。 $line-height 这个变量可以是 .wrapper 自己定义的局部变量（比如上面那段代码），也可以从更上层的作用域获取： 12345678910$line-height = 1.5 // 全局统一行高body line-height: $line-height.wrapper $max-lines = 3 max-height: unit($line-height * $max-lines, 'em') overflow-y: hidden 这意味着 .wrapper 可以向祖先继承行高，而不需要为这个 “只显示三行” 的需求把自己的行高写死。有了运算，我们就有能力表达属性与属性之间的关联，它令我们的代码更加灵活 函数把常用的运算操作抽象出来，我们就得到了函数。 开发者可以自定义函数，预处理器自己也内置了大量的函数。最常用的内置函数应该就是颜色的运算函数了吧！有了它们，我们甚至都不需要打开 Photoshop 来调色，就可以得到某个颜色的同色系变种了。 举个例子，我们要给一个按钮添加鼠标悬停效果，而最简单的悬停效果就是让按钮的颜色加深一些。我们写出的 CSS 代码可能是这样的： 123456.button &#123; background-color: #ff4466;&#125;.button:hover &#123; background-color: #f57900;&#125; 我相信即使是最资深的视觉设计师，也很难分清 #ff4466 和 #f57900 这两种颜色到底有什么关联。而如果我们的代码是用预处理语言来写的，那事情就直观多了： 123456button $color = #ff9833 background-color: $color &amp;:hover background-color: darken($color, 20%) 此外，预处理器的函数往往还支持默认参数、具名实参、 arguments 对象等高级功能，内部还可以设置条件分支，可以满足复杂的逻辑需求。","categories":[],"tags":[]},{"title":"5.17面试总结","slug":"20170517post","date":"2017-05-18T05:05:50.952Z","updated":"2017-05-18T14:11:46.816Z","comments":true,"path":"2017/05/18/20170517post/","link":"","permalink":"https://silkyer.github.io/2017/05/18/20170517post/","excerpt":"","text":"这天参加了两个面试 上午在大新 下午在下沙 上午的面试收获要比下午多多了先Mark上午面试的总结(这里只总结自己没回答好或者没回答上) ES6新增的箭头函数 作用是什么?和ES5相比 好处在哪回答这个问题之前,首先来看看这个问题: JS中this到底指向什么?这是个老生常谈的问题了,网上一堆大牛给出了答案,概括来说分4中情况: this作为对象方法调用、作为函数调用、作为构造函数调用、apply或call调用。 具体答案依然一搜一大堆,篇幅问题,且这里讲的是箭头函数,所以以 this作为函数调用 这一问题来分析 this作为函数被调用时函数也可以直接被调用，这个时候this被绑定到了全局对象。 123456ar x = 1; function test()&#123; this.x = 0; &#125; test(); alert(x); //this作为函数直接调用了!这里是语法糖有简写 输出为0 但这样就会出现一些问题，就是在函数内部定义的函数，其this也会指向全局，而和我们希望的恰恰相反。代码如下： 1234567891011var o = &#123; x : 1, func : function() &#123; console.log(this.x) &#125;, test : function() &#123; setTimeout(function() &#123; this.func(); &#125;, 100); &#125;&#125;;o.test(); // TypeError : this.func is not a function 上面的代码会出现错误，因为this的指向从o变为了全局（函数调用中的this都是指向全局的）。我们需要修改上面的代码如下： 123456789101112var o = &#123; x : 1, func : function() &#123; console.log(this.x) &#125;, test : function() &#123; var _this = this; setTimeout(function() &#123; _this.func(); &#125;, 100); &#125;&#125;;o.test(); 通过使用外部事先保存的this就行了 (其实这个所谓的外部保存this就是第一种情况: this作为对象被调用,此时的this,就是指向o对象!)。 这里就可以利用到箭头函数了，我们刚才说过， 箭头函数的 this 始终指向函数定义时的 this，而非执行时 也就是说,用了箭头函数,就省掉了用一个新的that去存外部this的指向了 123456789var o = &#123; x : 1, func : function() &#123; console.log(this.x) &#125;, test : function() &#123; setTimeout(() =&gt; &#123; this.func() &#125;, 100); &#125;&#125;;o.test(); PS: 测试表明,使用箭头函数,除了写法优雅以外,从性能上已经确定箭头函数比bind()快了 什么是CDN（问题：加快网页加载速度手段）CDN的全称是Content Delivery Network，即内容分发网络。 内容包括但不限于什么什么分布式存储、负载均衡、网络请求的重定向和内容管理4个技术性名词 总的来说就是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。解决网络拥挤的状况，提高用户访问网站的响应速度。 下面这则漫画简要的描述了CDN为何物和其作用： http://xiaoheiyang.baijia.baidu.com/article/126615 DNS为什么需要DNS解析域名为IP地址？网络通讯大部分是基于TCP/IP的，而TCP/IP是基于IP地址的，所以计算机在网络上进行通讯时只能识别如“202.96.134.133”之类的IP地址，而不能认识域名。我们无法记住10个以上IP地址的网站，所以我们访问网站时，更多的是在浏览器地址栏中输入域名，就能看到所需要的页面，这是因为有一个叫“DNS服务器”的计算机自动把我们的域名“翻译”成了相应的IP地址，然后调出IP地址所对应的网页。 什么是DNS？DNS( Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于TCP/IP网络，它所提供的服务是用来将主机名和域名转换为IP地址的工作。DNS就是这样的一位“翻译官”，它的基本工作原理可用下图来表示。 DNS过程DNS是应用层协议，事实上他是为其他应用层协议工作的，包括不限于HTTP和SMTP以及FTP，用于将用户提供的主机名解析为ip地址。 DNS 查询的过程如下图所示 1、在浏览器中输入www . qq .com 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(http://qq.com) 给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找 http://qq.com 域服务器，重复上面的动作，进行查询，直至找到 www . qq .com 主机。 6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 详见： https://www.zhihu.com/question/23042131 关于TCP/IP 四层协议其实了解过后发现，想要理解DNS，其实也离不开TCP/IP。HTTP协议就属于TCP/IP协议家族中的一员，前端经常要接触HTTP,自然很有必要理解一下什么是TCP/IP 什么是TCP/IP两台机器之间该如何通信，就需要制定各种各样的协议了。例如：文件传输适用TCP协议。域名系统适用DNS协议。有了些协议的存在，各种数据流按照规则传输，计算机之间得以通信。 TCP/IP协议是一个协议集合。统称为TCP/IP。TCP/IP协议族中有一个重要的概念是分层，TCP/IP协议按照层次分为以下四层。应用层、传输层、网络层、数据链路层。 HTTP 关系密切的协议 : IP、TCP 和 DNSIP协议：IP(Internet protocol),这里的IP不是值得我们通常所说的192.168.1.1.这个IP指的是一种协议，而后面的数字值得是IP地址。IP协议的作用在于把各种数据包准确无误的传递给对方，其中两个重要的条件是IP地址，和MAC地址（Media Access Control Address）。由于IP地址是稀有资源，不可能每个人都拥有一个IP地址，所以我们通常的IP地址是路由器给我们生成的IP地址，路由器里面会记录我们的MAC地址。而MAC地址是全球唯一的，除去人为因素外不可能重复。举一个现实生活中的例子，IP地址就如同是我们居住小区的地址，而MAC地址就是我们住的那栋楼那个房间那个人。 TCP协议：如果说IP协议是找到对方的详细地址。那么TCP协议就是把安全的把东西带给对方。各有分工，互不冲突。 按层次分，TCP属于传输层，提供可靠的字节流服务。什么叫字节流服务呢？所谓的字节流，其实就类似于信息切割。比如你是一个卖自行车的，你要去送货。安装好的自行车，太过庞大，又不稳定，容易损伤。不如直接把自行车拆开来，每个零件上都贴上收货人的姓名。最后送到后按照把属于同一个人的自行车再组装起来，这个拆解、运输、拼装的过程其实就是TCP字节流的过程。 为了确保信息能够确保准确无误的到达，TCP采用了著名的三次握手策略（three-way handshaking） 访问一个网站，从输入url到最终打开成功经历的http流程(面试时回答得不好,下图解释得再清楚不过了) 详情: http://www.cnblogs.com/roverliang/p/5176456.html CSS选择器以及预处理的作用篇幅太多,另起了一篇post,顺便简单列举和总结常用的一些选择器: https://silkyer.github.io/2017/05/18/CSS-selector/ 面试时没回答上,其实大部分都用过,但是用的次数太少,很多选择器是用过一次,实现了功能后,就很少机会试用第二次了.时间一长就忘记了,通过这次面试让我意识到前端不仅仅是JS,HTML和CSS还有其他相关的很多基础知识也很重要的 关于5.17号上午的面试在大新地铁站附近,环境很好.重点是,我最最在意的面试环节,其中太多细节感动到泪流满面: 1、这家公司是我见过的唯一一家提前打印好简历的,并且面试官会很详细的聊你的简历、在你的简历上做笔记，自己的简历被认真对待是一件很窝心的事情。如果能跟这样的面试官一起共事，先不说技术，就这种认真的态度也对自己受益终生 2、面试时人事旁听，在我和技术面试的过程中，人事在旁边观察也算是一种考核，也省去了双方的再一次人事面试，足以证明他们对应聘者的重视程度。 3、面试官提问很有技巧，问题面面俱到，能根据我的回答抓住我擅长的领域，并深挖下去，这样给我感觉是能挖掘出应聘者的潜力 4、如果您能看到，真的很感谢您在面试过程中对我耐心地解答我的疑虑。 再就是自己的不足了吧，除了上述的问题总结，在沟通过程中，由于自己面试失败次数太多，心态崩了，各种出糗。给人一种毛躁的印象。下一次面试的话，调整好自己的心态吧，命里无时莫强求。 总结这次的面试是我收获最大的一次面试，让我理解到，既然已经从事了IT这个行业，就势必要去了解下网络底层，虽然实际工作中这些东西用不到。高楼大厦，起于平川。不积跬步，无以至千里，不积小流，无以成江海。我现在的知识结构，就如同空中楼阁。稍微遇到高层次的问题，可能就理解不了了。一棵大树如果不在刚开始的时候深深的扎根，把所有的力量用到生长叶子开花上面。等到了大风来袭，互联网低潮的时候，一切来自不易的生活，就轻而易举的被倾覆。 理想是成为一个拥有渊博知识的人，拥有丰富的专业知识，足以应对工作中的难题。工作之余，博览群书，提升气质谈吐。","categories":[],"tags":[]},{"title":"Vue2.0仿外卖APP（五）","slug":"web-app05","date":"2017-05-16T14:25:27.413Z","updated":"2017-05-16T15:02:49.830Z","comments":true,"path":"2017/05/16/web-app05/","link":"","permalink":"https://silkyer.github.io/2017/05/16/web-app05/","excerpt":"","text":"header组件Vue-resource应用(当时的我还不知道axios..)https://github.com/pagekit/vue-resource vue-resource是Vue.js的一款插件，它可以通过XMLHttpRequest或JSONP发起请求并处理响应。也就是说，$.ajax能做的事情，vue-resource插件一样也能做到，而且vue-resource的API更为简洁。另外，vue-resource还提供了非常有用的inteceptor功能，使用inteceptor可以在请求前和请求后附加一些行为，比如使用inteceptor在ajax请求时显示loading界面。 vue-resource插件具有以下特点：体积小vue-resource非常小巧，在压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多。 支持主流的浏览器和Vue.js一样，vue-resource除了不支持IE 9以下的浏览器，其他主流的浏览器都支持。 支持Promise API和URI TemplatesPromise是ES6的特性，Promise的中文含义为“先知”，Promise对象用于异步计算。URI Templates表示URI模板，有些类似于ASP.NET MVC的路由模板。 支持拦截器拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。 关于vue-resource更详细的介绍:http://www.cnblogs.com/keepfool/p/5657065.html 获取数据 如图,Header组件里的商家数据，是通过异步请求后端的数据接口获得的，header组件就负责接受这样的数据并渲染 。在app.vue组件（header的父组件），通过发送一个AJAX请求去获取商家的相关数据，取回来的数据放进app.vue里的&lt;header&gt;标签,然后这些数据通过header组件里的prop属性设置一下后,数据就在header组件里,就可以调用这些数据来做我们想做的事情 父子组件间的通信组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模版中使用了组件 B 。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。然而，在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性。 在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。看看它们是怎么工作的。 使用 Prop 传递数据组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。prop 是父组件用来传递数据的一个自定义属性。子组件需要显式地用 props 选项声明 “prop”： 1234567Vue.component('child', &#123; // 声明 props props: ['message'], // 就像 data 一样，prop 可以用在模板内 // 同样也可以在 vm 实例中像 “this.message” 这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;) 然后向它传入一个普通字符串： 结果输出“hello”。 回到项目中来 首先我们需要给app.vue定义一个seller的对象：可以通过data()方法。在vue.js中，这个data属性是一个函数（可查看链接），因为组件是可以被复用的，如果定义一个对象然后修改某一个组件的话会影响另外的组件，所以这里定义成一个函数。这个函数return一个对象，对象里面有seller对象，先定为空，然后我们通过发送AJAX请求去拿到一个seller对象，然后send给它。这样就可以拿到seller对象的数据。 Vue.js社区有个第三方插件：vue-resource，用来处理一些前后端请求数据交互的。 示例： 12345678&#123; // GET /someUrl this.$http.get('/someUrl').then((response) =&gt; &#123; // success callback &#125;, (response) =&gt; &#123; // error callback &#125;);&#125; 同样的，需要在package.json添加它的依赖： 第三方插件import引用时需要注册，用Vue.use(vueResource)把这个注册。在main.js注册 然后回到app.vue，在这里我们需要通过一个vue.resource去发送一个AJAX请求，需要在什么时序去发起呢？ 我们知道每个vue实例化的时候都有一个生命周期，其中有个钩子叫created(). 关于钩子：https://segmentfault.com/q/1010000004335505 关于实例的生命周期：https://cn.vuejs.org/v2/guide/instance.html#实例生命周期 这是它的一个生命周期钩子函数，就是一个vue实例被生成后调用这个函数。一个vue实例被生成后还要绑定到某个html元素上，之后还要进行编译，然后再插入到document中。每一个阶段都会有一个钩子函数，方便开发者在不同阶段处理不同逻辑。 一般可以在created函数中调用ajax获取页面初始化所需的数据,如下图: 去chrome的network查看,看到请求已经发出去了 vue-resource就介绍完了，seller对象已经拿到，接下来就把seller对象传递给header组件，让header渲染即可。 这里还有一个坑!! Vue-resource 1.0的时候,右侧的response就能直接拿到seller字段 但是2.0时,resource封装的方法变了,需要response.body,才能拿到seller,不加body,只会拿到一个Object ##","categories":[],"tags":[]},{"title":"Vue2.0仿外卖APP（四）","slug":"web-app04","date":"2017-05-16T10:34:07.647Z","updated":"2017-05-16T14:25:16.451Z","comments":true,"path":"2017/05/16/web-app04/","link":"","permalink":"https://silkyer.github.io/2017/05/16/web-app04/","excerpt":"","text":"组建拆分先在static目录下引入reset.css 接着在index.html引入，并且设置移动端&lt;meta&gt;,viewport的 有时候由于eslint的检测功能,写js少一个冒号多一个空格都会频繁报错,这会让刚接触Vue或者对ES6不熟悉的人痛苦不堪,可以在上一节讲到的eslint相关配置处,把对应检测功能置零 如果不置零,下面这段代码就会报错: 所以要到eslintrc.js去设置 现在的App.vue如下： 然后我们编写组件来替换那三个区块。 创建header组件 将header引入到App.vue里面(注册)： Components后面要有空格。 这里还要安装一个stylus-loader依赖，不然会报错。 这里提供一个依赖包的安装方法：到package.json，在里面添加所需要的最新版本的包，然后再cnpm install ，这样就可以添加到node_modules里面了，运行cnpm run dev。 基本的组件结构如下: Vue-router因为在单页应用中，内容区块有三部分，所以这时候要用到路由vue-router http://router.vuejs.org/zh-cn/installation.html 同样通过package.json来安装。 vue-router的用法：http://router.vuejs.org/zh-cn/essentials/getting-started.html 可以参考下面两个链接: 官网的写法：http://router.vuejs.org/zh-cn/essentials/getting-started.html 参考：https://segmentfault.com/q/1010000007929093/a-1020000007929260(PS: 链接都是个人觉得在遇到困难时很好的解决思路,所以放上来供大家参考) 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)。在通过use()这个方法，相当于安装插件。 参照官网给的vue-router的过程： 12345678910111213141516171819202122232425262728293031// 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)// 1. 定义（路由）组件。// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;// 2. 定义路由// 每个路由应该映射一个组件。 其中\"component\" 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;]// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;)// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app')// 现在，应用已经启动了！ 所以,main.js是这样的: 1像素border实现border-bottom: 1px solid rgba(7, 17, 27, 0.1) 直接在.tab加这句话可以实现，但是在移动端看到的就不是这样的，因为手机端有个dpr的概念,电脑设置的1px不代表所有手机里面显示的都是1px:http://mobile.51cto.com/web-484304.htm 总的来说就是: 想要在dpr=2的设备下显示1px,对于css而言,可认为border: 0.5px,因为这是retina下(dpr=2)下能显示的最小单位。 然而，无奈并不是所有手机浏览器都能识别border: 0.5px;，ios7以下，android等其他系统里，0.5px会被当成为0px处理，那么如何实现这0.5px呢？ 由于项目中多处用到border1px,所以单独拿出来放到一个通用文件里: mixin.styl 这只是通用文件,真正实现1px,关键是检测出设备dpr,从而进行缩放 没错就是媒体查询@media 把检测dpr这个功能单独隔离出一个base.styl 所以为了使用border1px,则需要在使用的那个组件,同时@import (base.styl)和(mixin.styl),为了简洁,我们把这些需要单独引入的css文件,再放入一个总的styl文件: index.styl 至此,每一个需要用到border1px的地方,只需要: 总结一像素的实现：伪类+缩放（用一个class） 这样基本框架已经搭建好了，接下来就来开发组件。","categories":[],"tags":[]},{"title":"Vue2.0仿外卖APP（三）","slug":"web-app03","date":"2017-05-16T10:12:00.256Z","updated":"2017-05-16T10:30:51.074Z","comments":true,"path":"2017/05/16/web-app03/","link":"","permalink":"https://silkyer.github.io/2017/05/16/web-app03/","excerpt":"","text":"APP结构如下: 项目资源准备准备项目的各种图片资源等等 注意：在webpack可以不用css sprite，直接用单张图片，因为它会帮忙打包。 还有SVG图片，放大之后不会影响质量，在移动端开发中，通常会把色彩单一的图片做成SVG图片。这些不是直接用，利用一些工具去把这些SVG图片去转化成一个叫图标字体的文件，就可以在CSS引用了。 图标字体制作在项目开发前期，我们需要将设计师给的一些图片制作成字体图标 用一个叫IcoMoon的工具（https://icomoon.io/），它本身有的图标可以查看IcoMoon App，要用自定义图标的话可以在IcoMoon App里面点击Import Icons，将所有的SVG图片导入，就可以下载使用了。（里面的Get Code可以查看使用方法）。在下载之前可以点击左上角的preferences，设置一下名称：sell-icon 项目目录设计所有代码都在src文件目录下 入口文件main.js； 整个页面的vue实例文件App.vue； components：存放我们的组件文件，但我们不会像hello.vue一样直接放在里面，我们会多件一个子目录，像这样： 这样做是因为一个vue组件除了它的.vue文件以外，还可能包含一个图片相关资源等等。之前说过，组件一个很重要的设计原则就是就近维护，把一个组件相关资源都放在一个目录下。 还要创建一个common目录，包好一个公共的模块和资源，再在它其中添加三个子目录。 在这儿项目中，我们使用的css预处理器是stylus。 结构如下图： 并且将图标字体生成的style.css添加到stylus目录下，并改名为icon.styl，并改为stylus语法：把括号和分号去掉。 把asset目录删掉。 mock数据（模拟后台数据）作为前端经常需要模拟后台数据，我们称之为mock。 http://blog.csdn.net/sysuzjz/article/details/50317531 mock 的真正意义在于简化测试环境。假如你现在要测试一个dao，但是你有不想构建数据库环境就可以用mock模拟数据库的返回结果。 数据来源：data.json 我们模拟的数据请求就是从这里面读取数据，接下来就来编写这些接口。 打开build目录-dev-server.js（就是我们开发的webpack打包的一个入口文件），打开之后使用express这个框架去指一个nodeserver，我们也可以用express-router来编写这些接口请求。 先拿到这些数据(data.json)：1234var appData = require('../data.json');var seller = appData.seller;var goods = appData.goods;var ratings = appData.ratings; 编写路由，并编写接口：12345678910111213141516171819202122var apiRoutes = express.Router();apiRoutes.get('/seller', function (req, res) &#123; res.json(&#123; errno: 0, data: seller &#125;);&#125;);apiRoutes.get('/goods', function (req, res) &#123; res.json(&#123; errno: 0, data: goods &#125;);&#125;);apiRoutes.get('/ratings', function (req, res) &#123; res.json(&#123; errno: 0, data: ratings &#125;);&#125;); 要在express使用它，我们需要调用express的变量app： 1app.use('/api', apiRoutes); 这样我们就可以直接通过/goods来获取数据了。 完整的dev-server.js： 写完后要重新运行cnpm run dev，因为我们改的是node文件，然后http://localhost:8080/api/seller,如果能获取下面显示的数据,则代表数据获取成功","categories":[],"tags":[]},{"title":"Vue2.0仿外卖APP（二）","slug":"web-app02","date":"2017-05-16T06:21:07.692Z","updated":"2017-05-16T10:07:46.236Z","comments":true,"path":"2017/05/16/web-app02/","link":"","permalink":"https://silkyer.github.io/2017/05/16/web-app02/","excerpt":"","text":"Vue-cli开启vue.js项目github地址: https://github.com/vuejs/vue-cli Vue.js开发利器vue-cli，是vue的脚手架工具。 在工地上，脚手架是工人搭建好的架子，能够帮助工人们作业；在技术圈，脚手架就是来帮助我们编写好基础的代码的工具。Vue-cli就是帮助我们写好vue.js基础代码的工具。 使用Vue.js，当你构建一个原型的时候，你所需要做的通常就是通过 &lt;script&gt; 把Vue.js引入进来，然后就完事了。但是真实情况往往不是这样的。当我们真正开发一个应用的时候，我们不可避免的会用到一大堆的工具，模块化、预处理器、热模块加载、代码校验和测试。这些工具对于一个需要长期维护的大型应用是必须的，但是项目初始化将会是让人痛苦的事情。这就是为什么我们做了 vue-cli ，让一个简单的命令行工具来帮助你快速的构建一个拥有强大构建能力的Vue.js项目。 可以说，它仅仅是为了初始化。 使用方法(以下操作均在终端(git)进行):// 安装vue-cli：Vue-cli是一个node包，所以要通过cnpm去安装 cnpm install -g vue-cli // 使用vue-cli初始化项目 vue init webpack my-project // 进入到目录 cd my-project // 安装依赖，生成node_modules目录 cnpm install // 开始运行 cnpm run dev 上面的这些命令会从 vuejs-templates 拉取模板并安装，然后用npm安装依赖，最后你只需要用个npm脚本启动就能开始开发了。 使用vue-cli初始化项目vue init webpack my-project的语法为: vue init Template-name就是模板名称：模板就是安装成功后给你自动生成的一个代码模板。 这些官方的模板存在的意义在于提供强大的项目构建能力，以至于用户可以尽可能快速的进行开发。然而能否真正的发挥作用还在于你如何组织你的代码和你使用的其他库。 所有的官方模板都可以在 vuejs-templates organization找到。如果有一个新的模板放在了这里，你可以直接就用 vue init &lt;template-name&gt; &lt;project-name&gt;使用。你也可以运行 vue list 命令来看看现在有哪些官方模板是现在可用的。 模板分为三类官方模板，就是我们通常用的 webpack与webpack-simple两种的区别在于webpack-simple 没有包括Eslint 检查功能等等功能，普通项目基本用webpack-simple 就足够了. 自定义模板 vue init username/repo my-project 从自己的仓库去安装。 无论是官方模板还是自定义模板，它都是去GitHub repo里面安装的。比如webpack模板： https://github.com/vuejs-templates/webpack 这就是webpack仓库的模板地址： 点进去template这个目录： 这部分就是我们最终安装后会生成的代码。 Project-name：是安装后会在当前目录下生产一个名为project-name的一个目录，然后把它的模板、所有代码都自动生成到这个目录下。 无处不在的Vue组件每一个模板都有自己的作用：基础版本用于快速构建原型，高级版本用于正式开发。这些模板有许多共同的功能，如都支持 *.vue 组件。这意味着任何第三方的Vue组件都可以随意使用，并且可以轻而易举的发布在npm上 备注ESLint：http://eslint.org/docs/user-guide/configuring。在团队协作中，为避免低级 Bug、产出风格统一的代码，会预先制定编码规范。使用 Lint 工具和代码风格检测工具，则可以辅助编码规范执行，有效控制代码质量。 http://www.tuicool.com/articles/7JZZJzn Karma+Mocha：https://github.com/karma-runner/karma-mocha。单元测试 mocha是一个js的测试框架。Karma是一个驱动测试的Runner。也就是说，karma为测试框架准备运行环境，可以让这些测试在真正的浏览器里运行。 Nightwatch：http://nightwatchjs.org/。验收测试框架，使用Selenium WebDriver API以将Web应用测试自动化。它提供了简单的语法，支持使用JavaScript和CSS选择器，来编写运行在Selenium服务器上的端到端测试。 关于生成项目文件的介绍 以下内容选自: http://blog.csdn.net/hongchh/article/details/55113751 build目录和config目录：都是与webpack的配置相关。 node_modules目录：npm install安装的依赖代码库 src目录：存放项目源码 statis目录：存放一些第三方静态资源的。可以看到它里面只有一个.gitkeep文件，它的作用是当这个目录为空也可以把这个项目提交到git代码仓库里。因为通常如果你创建一个空目录，git会忽略掉这个目录，它是不会提交到仓库里的。 .babelrc文件： 它是babel的一些配置。因为我们的代码都是ES6，而大部分浏览器都是还不支持的。所以通常我们的做法是将ES6通过babel编译成ES5，而.babelrc就是babel编译的一些配置。其中presets表示预设，[“es2015”, “stage-2”]表示babel转换预先需要安装的插件。我们可以在node_modules里面可以看到这两个插件。 &quot;plugins&quot;: [&quot;transform-runtime&quot;]：把ES6的方法做转换。 .editorconfig文件：编辑器的配置 分别是编码、缩进风格、缩进大小、换行符的风格、文件末尾插入新行、自动移除多余空格。 .eslintignore文件：忽略语法检查的目录文件{% image http://opolpcrco.bkt.clouddn.com/17-5-16/79534917-file_1494917086240_24e.png '' '' %}表示不会对build目录下和config目录下中的js文件做ES语法检查。 .eslintrc.js文件：Eslint的配置文件 在上图中extends: ‘standard’：表示继承一个标准的规则，可以在这里看到：https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style都是预先定义好的规则。 我们也可以通过rules对一些具体的规则做修改。 比如： 这里就修改了三个规则。配置成0就是不想要之前定义好的规则。 no-debugger：做一个判断，如果是开发环境就可以debugger，是生产环境就不能，因为生产环境下debugger是非常危险的。 .gitignore文件： 就是git仓库去忽略掉这些文件或者目录，不会提交到代码里面。 Index.html文件：就是我们的入口html文件 没有css，js文件，因为我们引用的资源会在我们的项目编译过程中自动插入到这个html文件中。 Package.json文件：项目的配置文件，用来描述一个项目。 运行”npm run dev”的时候执行的是build/dev-server.js文件，运行”npm run build”的时候执行（用来执行发布的）的是build/build.js文件，下面我们可以从这两个文件开始进行代码阅读分析。 Readme文件：项目的描述文件。 至此,Vue-cli初始化的文件就全部介绍完了 项目运行上面介绍了目录里的文件,那这些文件是怎么执行的呢 先来看它的入口文件index.html 入口js文件是main.js 依赖了两个vue库中的Vue、App.vue中对的App。 接着实例化一个Vue的实例，element挂载到”#app”上；模板是App；然后再用components注册一个当前App的插件，ES6的简写。也就是这个实例依赖App这个组件。 App.vue组件： 图中,用了一个&lt;hello&gt;标签,其实就是vue-cli初始化后的首页:Hello,Vue同时也可以看到,注册了hello,才能以&lt;hello&gt;这样在HTML页面中使用 (这是页面请求到的文件资源) app.js：打包后生成的代码；没有css，那时因为webpack在打包的时候也把css打包到js里面了。 可以看到：app.js接近1m，这么大是因为我们把那些ES6语法在运行时做一个解析。 所以接下来我们聊聊webpack webpack打包Webpack：当前最火的前端构建工具。http://webpack.github.io/ Webpack的功能：把各种各样的前端资源编译打包，最终输出css,图片和js。 Webpack的配置很复杂,vue-cli已经帮我们完成了95%的配置工作 总结起来就是: 当文档最终生成一个app.js时，源码中并没有这个文件，这个就是因为webpack的编译,打包 npm run dev 到底是什么?我们都知道,想运行一个Vue-cli初始化好的文件,预览效果,需要执行npm run dev ,那过程中到底发生了什么? npm run dev其实就是执行了”node build/dev-server.js”这个命令，运行了build目录下的dev-server.js文件 这个文件首先是有各种依赖： 由上至下的语句分别: Path就是node.js提供的API，提供一些文件路径操作的方法； Express是node.js的一个框架，这里用它去启动一个webserver； Webpack就是核心编译工具，直接用node.js提供的API，而不用全局的webpack； proxyMiddleware就是HTTP代理的一个中间件，可以代理和转发API ; WebpackConfig就是webpack的相关配置，这里由于是一个开发时的配置，所以它是依赖webpack.dev.conf。 看一下这个配置文件webpack.dev.conf： 除了刚刚提到的一些依赖，还有依赖一个webpack-merge，就是用来合并配置文件的； Utils就是工具方法； baseWebpackConfig也是一个webpack配置文件，它是被开发时的配置文件和运行时的配置文件所共享的； HtmlWebpackPlugin就是webpack提供的一个操作HTML文件的一个插件。 Webpack.base.conf.js文件：定义webpack一些基础配置 Webpack.base.conf.js文件里面又有什么呢? projectRoot定义了当前项目的根目录； Module.exports = {这里面就是webpack的基本配置 entry：一个入口配置。app: ‘./src/main.js’表示webpack编译的入口js文件 Output：输出的配置。path是路径；filename输出的文件名名称 Resolve：就是代码中request、import的一些相关配置。Extensions自动补全文件后缀名；fallback指向node_modules这个模块，也就是说当我们在前端request模块找不到的时候就可以在node_modules里面找；alias提供一些别名，也就是request路径中可以通过别名缩短书写。 resolveLoader：里面的fallback跟上面类似。 Module：preLoaders、loaders类似，对某种类型的文献应用某一个loader去做处理，webpack编译阶段就是利用各种loader对各种文件做编译。不同的文件利用不同的loader做处理。 Eslint：formatter当eslint检查到错误的时候会有好地提示一个信息并且提供链接查看错误原因。 Vue： 与css有关，utils里面 }","categories":[],"tags":[]},{"title":"Vue一些知识点","slug":"Vue一些知识点","date":"2017-05-16T06:14:01.965Z","updated":"2017-05-16T06:19:25.989Z","comments":true,"path":"2017/05/16/Vue一些知识点/","link":"","permalink":"https://silkyer.github.io/2017/05/16/Vue一些知识点/","excerpt":"","text":"1、 使用组件时，大多数可以传入到 Vue 构造器中的选项可以在注册组件时使用，有一个例外： data 必须是函数。 实际上，如果你使用的不是函数，那么 Vue 会在控制台发出警告，告诉你在组件中 data 必须是一个函数。 下面的例子会让所有的组件都同时发生变化 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"example-2\"&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt;&lt;/div&gt;&lt;script&gt;var data = &#123; counter: 0 &#125;Vue.component('simple-counter', &#123; template: '&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', // data 是一个函数，因此 Vue 不会警告， // 但是我们为每一个组件返回了同一个对象引用 data: function () &#123; return data &#125;&#125;)new Vue(&#123; el: '#example-2'&#125;)&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 由于这三个组件共享了同一个 data ， 因此增加一个 counter 会影响所有组件！我们可以通过为每个组件返回新的 data 对象来解决这个问题： 12345data: function () &#123; return &#123; counter: 0 &#125;&#125; https://cn.vuejs.org/v2/guide/components.html#data-必须是函数https://segmentfault.com/q/1010000007910818?_ea=1490198","categories":[],"tags":[]},{"title":"Vue2.0仿外卖APP（一）","slug":"web-app01","date":"2017-05-15T15:19:24.724Z","updated":"2017-05-16T03:59:06.325Z","comments":true,"path":"2017/05/15/web-app01/","link":"","permalink":"https://silkyer.github.io/2017/05/15/web-app01/","excerpt":"","text":"最近在学习慕课网的课程：用vue.js做一个仿饿了么外卖APP的项目，现在也把流程啊什么的暂时先整理一下在这个博客上面。 当然，这个过程会有点长，不过确实能学到很多东西。 话不多说，马上开始吧。 注：当我们把用vue-cli脚手架搭建成的vue项目复制到其他地方时，要把node_modules目录删除，不然在其他地方无法执行cnpm run dev，这其中设计到路径的问题。删除之后要重新cnpm install。 https://segmentfault.com/q/1010000006912664 https://www.zhihu.com/question/41409670?sort=created 1.项目介绍选用当前最火的MVVM框架作为这个项目的技术栈MVVM架构： View和model通过viewModel来通信，但数据发生变化，viewmodel能够观察到这种数据的变化，然后通知到对应的视图做自动更新；当用户操作view视图，viewModel也能监听到视图的变化，然后通知数据做改动，实现了数据的双向绑定。 应用场景： 针对具有复杂交互逻辑的前端应用； 它可以提供基础的架构抽象； 可以通过AJAX数据持久化，保证前端用户体验 好处： 当前端和数据做一些操作的时候，可以通过AJAX请求对后端做数据持久化，不需要刷新整个页面，只需要改动DOM里需要改动的那部分数据。特别是移动端应用场景，刷新页面太昂贵，会重新加载很多资源，虽然有些会被缓存，但是页面的DOM,JS,CSS都会被页面重新解析一遍，因此移动端页面通常会做出SPA单页应用。 该项目只提取饿了么其中一个模块–商家模块进行开发 项目开发的一个完整流程项目的需求分析–脚手架工具–数据mock–架构设计–代码编写–自测–编译打包等方面完全简讲述开发一个web的全流程，更好地了解一个项目从0到1的过程。 所需技术：项目完整的开发流程；组件化、模块化的开发模式；使用Vue-cli脚手架初始化Vue.js项目；webpack的打包原理；模拟json后端数据，前后端分离开发；es6+eslint的开发方式。 第三方组件：使用stylus编写模块化的CSS；使用vue-router开发单页应用；使用vue-resource与后端数据交互；在Vue.js框架里和第三方JS插件交互。 关于Vue的数据驱动思想在数据驱动的思想里，数据驱动DOM变化，DOM是数据的一种自然映射。 如果没有MVVM框架，数据和视图是如何交互的？ 比如通过AJAX从后端获取数据，会让视图改变，通过手动触发DOM的改变；再比如我们通过前端交互改变一些数据，为了让视图也发生变化，仍然需要通过手动触发进行DOM改变。手动改变DOM不仅繁琐，还容易出错。用了vue之后就可以省去操作DOM变化的步骤了。 在vue.js中，可以通过directives指令去对DOM做一层封装，当数据发生变化，会通知指令去修改对应的DOM。 Vue.js还会对操作做监听，当我们修改视图的时候，vue.js监听到这些变化，从而改变数据。 (↑上面两幅图红色区域代表正在执行该逻辑)这样就实现了数据的双向绑定。 vue.js数据响应的原理vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 思路整理 已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一，如果不熟悉defineProperty，猛戳→这里 整理了一下，要实现mvvm的双向绑定，就必须要实现以下几点：1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图4、mvvm入口函数，整合以上三者 详情可查看: 剖析Vue原理&amp;实现双向绑定MVVM (先把app做出来,回头来研究) 关于vue组件化的思想目的：拓展HTML元素，封装可重用代码 如下图：左侧是一个页面，被拆分成小的区块，每个区块对应一个组件，组件可以嵌套，最终组合成为一个完整页面。 在vue.js中，每个组件都对应一个viewModel，最终生成一个viewModel的树： 组件化讲解一个简单的HTML页面，以此为基础： 12345678910111213141516171819&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;揭开Vue组件的神秘面纱&lt;/title&gt; &lt;/head&gt; &lt;body&gt; //这中间就是实例挂载点的实例边界 &lt;div id=\"vueInstance\"&gt;&lt;/div&gt; &lt;script src=\"http://cdn.jsdelivr.net/vue/1.0.16/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; // 创建一个新的Vue实例，并设置挂载点 var V = new Vue(&#123; el : '#vueInstance' &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在Vue中，可以使用Vue.component()来创建和注册你的组件，这个构造器有两个参数：组件的名字；包含组件参数的对象。 接下来注册一个组件。创建并传入两个参数：组件的名字:’mine’；包含组件参数的对象:这个对象包含一个属性’template’。 123Vue.component('mine',&#123; template : '&lt;p&gt;My name is Appian.&lt;/p&gt;'&#125;) 现在你已经有了自己的一个组件了，你可以在你的应用的任何地方使用它。只要你调用它的唯一标识(就是组件名字)，并用普通html标签的格式来书写，比如，组件上注册的内容就会在你的自定义标签的地方插入。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue组件&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"vueInstance\"&gt; &lt;mine&gt;&lt;/mine&gt; &lt;mine&gt;&lt;/mine&gt; &lt;mine&gt;&lt;/mine&gt; &lt;/div&gt; &lt;script src=\"http://cdn.jsdelivr.net/vue/1.0.16/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('mine',&#123; //这里就是注册的内容 template : '&lt;p&gt;My name is Vue.&lt;/p&gt;' &#125;); // 创建一个新的Vue实例，并设置挂载点 var V = new Vue(&#123; el : '#vueInstance' &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用template标签处理复杂组件如果总是在vue.component()构造器里写html代码，复杂页面就不得了了。为了避免上面的这种情况，所以我们可以用template标签（注意属性和标签是不一样的）来达到我们的目的。我们可以在页面的任何地方，定义template标签，并在template标签内，写好我们的模板。 因为template标签在页面加载的时候不会渲染出来，只有在我们需要它的时候，这个标签内的内容才会被渲染出来。所以，你可以把template标签放在任何地方，并给它一个id，以便在组件注册的时候能够找到模板。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue组件&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"vueInstance\"&gt; &lt;mine&gt;&lt;/mine&gt; &lt;/div&gt; &lt;template id=\"myVue\"&gt; &lt;p&gt;i am vue&lt;/p&gt; &lt;p&gt;welcome!&lt;/p&gt; &lt;/template&gt; &lt;script src=\"http://cdn.jsdelivr.net/vue/1.0.16/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('mine',&#123; //这里就是注册的内容 template : '#myVue' &#125;); // 创建一个新的Vue实例，并设置挂载点 var V = new Vue(&#123; el : '#vueInstance' &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过props向组件中传递数据Vue是处理父组件向子组件中传递数据是通过props。 1234Vue.component('mine',&#123; template : '&lt;p&gt;Appian is from &#123;&#123; city &#125;&#125;.&lt;/p&gt;', props : ['city']&#125;); props可以是数组，也可以是对象。 那父组件那里又是怎么指派字段给子组件的呢？ 只需要在对应的标签内写下属性就好 1&lt;mine city=\"welcome\"&gt;&lt;/mine&gt;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-05-13T06:07:47.892Z","updated":"2017-05-13T06:07:47.925Z","comments":true,"path":"2017/05/13/hello-world/","link":"","permalink":"https://silkyer.github.io/2017/05/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}