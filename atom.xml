<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SilkYer&#39;s Blog</title>
  <subtitle>Write the code , Change the world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://silkyer.github.io/"/>
  <updated>2017-05-16T10:30:51.074Z</updated>
  <id>https://silkyer.github.io/</id>
  
  <author>
    <name>SilkYer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue2.0仿外卖APP（三）</title>
    <link href="https://silkyer.github.io/2017/05/16/web-app03/"/>
    <id>https://silkyer.github.io/2017/05/16/web-app03/</id>
    <published>2017-05-16T10:12:00.256Z</published>
    <updated>2017-05-16T10:30:51.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="APP结构如下"><a href="#APP结构如下" class="headerlink" title="APP结构如下:"></a>APP结构如下:</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/63895726-file_1494929641181_94fe.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/70823900-file_1494929641368_a94b.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/48455974-file_1494929641511_39ed.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="项目资源准备"><a href="#项目资源准备" class="headerlink" title="项目资源准备"></a>项目资源准备</h3><p>准备项目的各种图片资源等等</p>
<p>注意：在webpack可以不用css sprite，直接用单张图片，因为它会帮忙打包。</p>
<p>还有SVG图片，放大之后不会影响质量，在移动端开发中，通常会把色彩单一的图片做成SVG图片。这些不是直接用，利用一些工具去把这些SVG图片去转化成一个叫图标字体的文件，就可以在CSS引用了。</p>
<h3 id="图标字体制作"><a href="#图标字体制作" class="headerlink" title="图标字体制作"></a>图标字体制作</h3><p>在项目开发前期，我们需要将设计师给的一些图片制作成字体图标</p>
<p>用一个叫IcoMoon的工具（<a href="https://icomoon.io/），它本身有的图标可以查看IcoMoon" target="_blank" rel="external">https://icomoon.io/），它本身有的图标可以查看IcoMoon</a> App，要用自定义图标的话可以在IcoMoon App里面点击Import Icons，将所有的SVG图片导入，就可以下载使用了。（里面的Get Code可以查看使用方法）。在下载之前可以点击左上角的preferences，设置一下名称：sell-icon</p>
<h3 id="项目目录设计"><a href="#项目目录设计" class="headerlink" title="项目目录设计"></a>项目目录设计</h3><p>所有代码都在src文件目录下</p>
<p>入口文件main.js；</p>
<p>整个页面的vue实例文件App.vue；</p>
<p>components：存放我们的组件文件，但我们不会像hello.vue一样直接放在里面，我们会多件一个子目录，像这样：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/70858233-file_1494929740581_12fd8.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>这样做是因为一个vue组件除了它的.vue文件以外，还可能包含一个图片相关资源等等。之前说过，组件一个很重要的设计原则就是就近维护，把一个组件相关资源都放在一个目录下。</p>
<p>还要创建一个common目录，包好一个公共的模块和资源，再在它其中添加三个子目录。</p>
<p>在这儿项目中，我们使用的css预处理器是stylus。</p>
<p>结构如下图：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/94710955-file_1494929781060_69d6.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>并且将图标字体生成的style.css添加到stylus目录下，并改名为icon.styl，并改为stylus语法：把括号和分号去掉。</p>
<p>把asset目录删掉。</p>
<h2 id="mock数据（模拟后台数据）"><a href="#mock数据（模拟后台数据）" class="headerlink" title="mock数据（模拟后台数据）"></a>mock数据（模拟后台数据）</h2><p>作为前端经常需要模拟后台数据，我们称之为mock。</p>
<p><a href="http://blog.csdn.net/sysuzjz/article/details/50317531" target="_blank" rel="external">http://blog.csdn.net/sysuzjz/article/details/50317531</a></p>
<p>mock 的真正意义在于简化测试环境。假如你现在要测试一个dao，但是你有不想构建数据库环境就可以用mock模拟数据库的返回结果。</p>
<p>数据来源：data.json<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/40072671-file_1494929832340_7438.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>我们模拟的数据请求就是从这里面读取数据，接下来就来编写这些接口。</p>
<p>打开build目录-dev-server.js（就是我们开发的webpack打包的一个入口文件），打开之后使用express这个框架去指一个nodeserver，我们也可以用express-router来编写这些接口请求。</p>
<p>先拿到这些数据(data.json)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var appData = require(<span class="string">'../data.json'</span>);</div><div class="line">var seller = appData.seller;</div><div class="line">var goods = appData.goods;</div><div class="line">var ratings = appData.ratings;</div></pre></td></tr></table></figure></p>
<p>编写路由，并编写接口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var apiRoutes = express.Router();</div><div class="line"></div><div class="line">apiRoutes.get(<span class="string">'/seller'</span>, <span class="keyword">function</span> (req, res) &#123;</div><div class="line">  res.json(&#123;</div><div class="line">    errno: 0,</div><div class="line">    data: seller</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">apiRoutes.get(<span class="string">'/goods'</span>, <span class="keyword">function</span> (req, res) &#123;</div><div class="line">  res.json(&#123;</div><div class="line">    errno: 0,</div><div class="line">    data: goods</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">apiRoutes.get(<span class="string">'/ratings'</span>, <span class="keyword">function</span> (req, res) &#123;</div><div class="line">  res.json(&#123;</div><div class="line">    errno: 0,</div><div class="line">    data: ratings</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>要在express使用它，我们需要调用express的变量app：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="string">'/api'</span>, apiRoutes);</div></pre></td></tr></table></figure>
<p>这样我们就可以直接通过<code>/goods</code>来获取数据了。</p>
<p>完整的dev-server.js：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/96312509-file_1494930527681_144f1.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>写完后要重新运行cnpm run dev，因为我们改的是node文件，然后<a href="http://localhost:8080/api/seller,如果能获取下面显示的数据,则代表数据获取成功" target="_blank" rel="external">http://localhost:8080/api/seller,如果能获取下面显示的数据,则代表数据获取成功</a><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/76637291-file_1494930638800_17dac.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;APP结构如下&quot;&gt;&lt;a href=&quot;#APP结构如下&quot; class=&quot;headerlink&quot; title=&quot;APP结构如下:&quot;&gt;&lt;/a&gt;APP结构如下:&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue2.0仿外卖APP（二）</title>
    <link href="https://silkyer.github.io/2017/05/16/web-app02/"/>
    <id>https://silkyer.github.io/2017/05/16/web-app02/</id>
    <published>2017-05-16T06:21:07.692Z</published>
    <updated>2017-05-16T10:07:46.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-cli开启vue-js项目"><a href="#Vue-cli开启vue-js项目" class="headerlink" title="Vue-cli开启vue.js项目"></a>Vue-cli开启vue.js项目</h2><p>github地址: <a href="https://github.com/vuejs/vue-cli" target="_blank" rel="external">https://github.com/vuejs/vue-cli</a></p>
<p>Vue.js开发利器vue-cli，是vue的脚手架工具。</p>
<p>在工地上，脚手架是工人搭建好的架子，能够帮助工人们作业；在技术圈，脚手架就是来帮助我们编写好基础的代码的工具。Vue-cli就是帮助我们写好vue.js基础代码的工具。</p>
<p>使用Vue.js，当你构建一个原型的时候，你所需要做的通常就是通过 <code>&lt;script&gt;</code> 把Vue.js引入进来，然后就完事了。但是真实情况往往不是这样的。当我们真正开发一个应用的时候，我们不可避免的会用到一大堆的工具，模块化、预处理器、热模块加载、代码校验和测试。这些工具对于一个需要长期维护的大型应用是必须的，但是项目初始化将会是让人痛苦的事情。这就是为什么我们做了 vue-cli ，让一个简单的命令行工具来帮助你快速的构建一个拥有强大构建能力的Vue.js项目。</p>
<p>可以说，它仅仅是为了初始化。</p>
<h3 id="使用方法-以下操作均在终端-git-进行"><a href="#使用方法-以下操作均在终端-git-进行" class="headerlink" title="使用方法(以下操作均在终端(git)进行):"></a>使用方法(以下操作均在终端(git)进行):</h3><p>// 安装vue-cli：Vue-cli是一个node包，所以要通过cnpm去安装</p>
<blockquote>
<p>cnpm install -g vue-cli</p>
</blockquote>
<p>// 使用vue-cli初始化项目</p>
<blockquote>
<p>vue init webpack my-project</p>
</blockquote>
<p>// 进入到目录</p>
<blockquote>
<p>cd my-project</p>
</blockquote>
<p>// 安装依赖，生成node_modules目录</p>
<blockquote>
<p>cnpm install</p>
</blockquote>
<p>// 开始运行</p>
<blockquote>
<p>cnpm run dev</p>
</blockquote>
<p>上面的这些命令会从 <a href="https://github.com/vuejs-templates" target="_blank" rel="external">vuejs-templates</a> 拉取模板并安装，然后用npm安装依赖，最后你只需要用个npm脚本启动就能开始开发了。</p>
<h3 id="使用vue-cli初始化项目"><a href="#使用vue-cli初始化项目" class="headerlink" title="使用vue-cli初始化项目"></a>使用vue-cli初始化项目</h3><p>vue init webpack my-project的语法为:</p>
<blockquote>
<p>vue init <template-name> <project-name></project-name></template-name></p>
</blockquote>
<p>Template-name就是模板名称：模板就是安装成功后给你自动生成的一个代码模板。</p>
<p>这些官方的模板存在的意义在于提供强大的项目构建能力，以至于用户可以尽可能快速的进行开发。然而能否真正的发挥作用还在于你如何组织你的代码和你使用的其他库。</p>
<p>所有的官方模板都可以在 <a href="https://github.com/vuejs-templates" target="_blank" rel="external">vuejs-templates organization</a>找到。如果有一个新的模板放在了这里，你可以直接就用 <code>vue init &lt;template-name&gt; &lt;project-name&gt;</code>使用。你也可以运行 vue list 命令来看看现在有哪些官方模板是现在可用的。</p>
<h3 id="模板分为三类"><a href="#模板分为三类" class="headerlink" title="模板分为三类"></a>模板分为三类</h3><h4 id="官方模板，就是我们通常用的"><a href="#官方模板，就是我们通常用的" class="headerlink" title="官方模板，就是我们通常用的"></a>官方模板，就是我们通常用的</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/92531555-file_1494916672780_9edc.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>webpack与webpack-simple两种的区别在于webpack-simple 没有包括Eslint 检查功能等等功能，普通项目基本用webpack-simple 就足够了.</p>
<h4 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h4><blockquote>
<p>vue init username/repo my-project</p>
</blockquote>
<p>从自己的仓库去安装。</p>
<p>无论是官方模板还是自定义模板，它都是去GitHub repo里面安装的。比如webpack模板：</p>
<p><a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="external">https://github.com/vuejs-templates/webpack</a></p>
<p>这就是webpack仓库的模板地址：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/69857513-file_1494916745714_7178.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>点进去template这个目录：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/92005949-file_1494916823044_1080d.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这部分就是我们最终安装后会生成的代码。</p>
<p>Project-name：是安装后会在当前目录下生产一个名为project-name的一个目录，然后把它的模板、所有代码都自动生成到这个目录下。</p>
<h3 id="无处不在的Vue组件"><a href="#无处不在的Vue组件" class="headerlink" title="无处不在的Vue组件"></a>无处不在的Vue组件</h3><p>每一个模板都有自己的作用：基础版本用于快速构建原型，高级版本用于正式开发。这些模板有许多共同的功能，如都支持 *.vue 组件。这意味着任何第三方的Vue组件都可以随意使用，并且可以轻而易举的发布在npm上</p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>ESLint：<a href="http://eslint.org/docs/user-guide/configuring。在团队协作中，为避免低级" target="_blank" rel="external">http://eslint.org/docs/user-guide/configuring。在团队协作中，为避免低级</a> Bug、产出风格统一的代码，会预先制定编码规范。使用 Lint 工具和代码风格检测工具，则可以辅助编码规范执行，有效控制代码质量。</p>
<p><a href="http://www.tuicool.com/articles/7JZZJzn" target="_blank" rel="external">http://www.tuicool.com/articles/7JZZJzn</a></p>
<p>Karma+Mocha：<a href="https://github.com/karma-runner/karma-mocha。单元测试" target="_blank" rel="external">https://github.com/karma-runner/karma-mocha。单元测试</a></p>
<p>mocha是一个js的测试框架。Karma是一个驱动测试的Runner。也就是说，karma为测试框架准备运行环境，可以让这些测试在真正的浏览器里运行。</p>
<p>Nightwatch：<a href="http://nightwatchjs.org/。验收测试框架，使用Selenium" target="_blank" rel="external">http://nightwatchjs.org/。验收测试框架，使用Selenium</a> WebDriver API以将Web应用测试自动化。它提供了简单的语法，支持使用JavaScript和CSS选择器，来编写运行在Selenium服务器上的端到端测试。</p>
<h3 id="关于生成项目文件的介绍"><a href="#关于生成项目文件的介绍" class="headerlink" title="关于生成项目文件的介绍"></a>关于生成项目文件的介绍</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/34871440-file_1494916910097_ba6f.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>以下内容选自: <a href="http://blog.csdn.net/hongchh/article/details/55113751" target="_blank" rel="external">http://blog.csdn.net/hongchh/article/details/55113751</a></p>
<p>build目录和config目录：都是与webpack的配置相关。</p>
<p>node_modules目录：npm install安装的依赖代码库</p>
<p>src目录：存放项目源码</p>
<p>statis目录：存放一些第三方静态资源的。可以看到它里面只有一个.gitkeep文件，它的作用是当这个目录为空也可以把这个项目提交到git代码仓库里。因为通常如果你创建一个空目录，git会忽略掉这个目录，它是不会提交到仓库里的。</p>
<p>.babelrc文件：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/59380736-file_1494916947815_d6cc.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>它是babel的一些配置。因为我们的代码都是ES6，而大部分浏览器都是还不支持的。所以通常我们的做法是将ES6通过babel编译成ES5，而.babelrc就是babel编译的一些配置。其中presets表示预设，[“es2015”, “stage-2”]表示babel转换预先需要安装的插件。我们可以在node_modules里面可以看到这两个插件。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/57654412-file_1494916967335_a377.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><code>&quot;plugins&quot;: [&quot;transform-runtime&quot;]</code>：把ES6的方法做转换。</p>
<p><code>.editorconfig</code>文件：编辑器的配置<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/82515434-file_1494917052138_98ca.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>分别是编码、缩进风格、缩进大小、换行符的风格、文件末尾插入新行、自动移除多余空格。</p>
<p><code>.eslintignore</code>文件：忽略语法检查的目录文件<br>{% image http://opolpcrco.bkt.clouddn.com/17-5-16/79534917-file_1494917086240_24e.png '' '' %}<br>表示不会对build目录下和config目录下中的js文件做ES语法检查。</p>
<p><code>.eslintrc.js</code>文件：Eslint的配置文件<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/23439141-file_1494917106915_13487.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<blockquote>
<p>在上图中<br>extends: ‘standard’：<br>表示继承一个标准的规则，可以在这里看到：<br><a href="https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style" target="_blank" rel="external">https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style</a><br>都是预先定义好的规则。</p>
</blockquote>
<p>我们也可以通过rules对一些具体的规则做修改。</p>
<p>比如：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/23439141-file_1494917106915_13487.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这里就修改了三个规则。配置成0就是不想要之前定义好的规则。</p>
<p><code>no-debugger</code>：做一个判断，如果是开发环境就可以debugger，是生产环境就不能，因为生产环境下debugger是非常危险的。</p>
<p><code>.gitignore</code>文件：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/82977245-file_1494917336733_a203.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>就是git仓库去忽略掉这些文件或者目录，不会提交到代码里面。</p>
<p>Index.html文件：就是我们的入口html文件<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/61916886-file_1494917371302_bae9.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>没有css，js文件，因为我们引用的资源会在我们的项目编译过程中自动插入到这个html文件中。</p>
<p>Package.json文件：项目的配置文件，用来描述一个项目。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/49316369-file_1494917411955_cd09.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>运行”npm run dev”的时候执行的是build/dev-server.js文件，运行”npm run build”的时候执行（用来执行发布的）的是build/build.js文件，下面我们可以从这两个文件开始进行代码阅读分析。</p>
<p>Readme文件：项目的描述文件。</p>
<p>至此,Vue-cli初始化的文件就全部介绍完了</p>
<h2 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h2><p>上面介绍了目录里的文件,那这些文件是怎么执行的呢</p>
<p>先来看它的入口文件index.html</p>
<p>入口js文件是main.js<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/38736490-file_1494926875474_fd86.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>依赖了两个vue库中的Vue、App.vue中对的App。</p>
<p>接着实例化一个Vue的实例，element挂载到”#app”上；模板是App；然后再用components注册一个当前App的插件，ES6的简写。也就是这个实例依赖App这个组件。</p>
<p>App.vue组件：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/38515883-file_1494927078778_72d2.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>图中,用了一个<code>&lt;hello&gt;</code>标签,其实就是vue-cli初始化后的首页:Hello,Vue<br>同时也可以看到,注册了hello,才能以<code>&lt;hello&gt;</code>这样在HTML页面中使用</p>
<p><img src="http://opolpcrco.bkt.clouddn.com/17-5-16/61647258-file_1494927309812_1f7.png" alt=""></p>
<p><center>(这是页面请求到的文件资源)</center></p>
<p>app.js：打包后生成的代码；没有css，那时因为webpack在打包的时候也把css打包到js里面了。</p>
<p>可以看到：app.js接近1m，这么大是因为我们把那些ES6语法在运行时做一个解析。</p>
<p>所以接下来我们聊聊webpack</p>
<h3 id="webpack打包"><a href="#webpack打包" class="headerlink" title="webpack打包"></a>webpack打包</h3><p>Webpack：当前最火的前端构建工具。<a href="http://webpack.github.io/" target="_blank" rel="external">http://webpack.github.io/</a></p>
<p>Webpack的功能：把各种各样的前端资源编译打包，最终输出css,图片和js。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/84315366-file_1494927466902_11d8c.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>Webpack的配置很复杂,vue-cli已经帮我们完成了95%的配置工作</p>
<p>总结起来就是: 当文档最终生成一个app.js时，源码中并没有这个文件，这个就是因为webpack的编译,打包</p>
<h3 id="npm-run-dev-到底是什么"><a href="#npm-run-dev-到底是什么" class="headerlink" title="npm run dev 到底是什么?"></a>npm run dev 到底是什么?</h3><p>我们都知道,想运行一个Vue-cli初始化好的文件,预览效果,需要执行npm run dev ,那过程中到底发生了什么?</p>
<p>npm run dev其实就是执行了”node build/dev-server.js”这个命令，运行了build目录下的dev-server.js文件</p>
<p>这个文件首先是有各种依赖：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/92938134-file_1494927855738_167c3.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p><center>由上至下的语句分别: </center></p>
<p>Path就是node.js提供的API，提供一些文件路径操作的方法；</p>
<p>Express是node.js的一个框架，这里用它去启动一个webserver；</p>
<p>Webpack就是核心编译工具，直接用node.js提供的API，而不用全局的webpack；</p>
<p>proxyMiddleware就是HTTP代理的一个中间件，可以代理和转发API ;</p>
<p>WebpackConfig就是webpack的相关配置，这里由于是一个开发时的配置，所以它是依赖webpack.dev.conf。</p>
<p>看一下这个配置文件webpack.dev.conf：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/48069299-file_1494929139658_1657c.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>除了刚刚提到的一些依赖，还有依赖一个webpack-merge，就是用来合并配置文件的；</p>
<p>Utils就是工具方法；</p>
<p>baseWebpackConfig也是一个webpack配置文件，它是被开发时的配置文件和运行时的配置文件所共享的；</p>
<p>HtmlWebpackPlugin就是webpack提供的一个操作HTML文件的一个插件。</p>
<p>Webpack.base.conf.js文件：定义webpack一些基础配置</p>
<p>Webpack.base.conf.js文件里面又有什么呢?<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-16/82117903-file_1494929197678_12fb0.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>projectRoot定义了当前项目的根目录；</p>
<p>Module.exports = {这里面就是webpack的基本配置</p>
<p>  entry：一个入口配置。app: ‘./src/main.js’表示webpack编译的入口js文件</p>
<p>  Output：输出的配置。path是路径；filename输出的文件名名称</p>
<p>  Resolve：就是代码中request、import的一些相关配置。Extensions自动补全文件后缀名；fallback指向node_modules这个模块，也就是说当我们在前端request模块找不到的时候就可以在node_modules里面找；alias提供一些别名，也就是request路径中可以通过别名缩短书写。</p>
<p>  resolveLoader：里面的fallback跟上面类似。</p>
<p>  Module：preLoaders、loaders类似，对某种类型的文献应用某一个loader去做处理，webpack编译阶段就是利用各种loader对各种文件做编译。不同的文件利用不同的loader做处理。</p>
<p>  Eslint：formatter当eslint检查到错误的时候会有好地提示一个信息并且提供链接查看错误原因。</p>
<p>  Vue： 与css有关，utils里面</p>
<p>}</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vue-cli开启vue-js项目&quot;&gt;&lt;a href=&quot;#Vue-cli开启vue-js项目&quot; class=&quot;headerlink&quot; title=&quot;Vue-cli开启vue.js项目&quot;&gt;&lt;/a&gt;Vue-cli开启vue.js项目&lt;/h2&gt;&lt;p&gt;github地址: 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue一些知识点</title>
    <link href="https://silkyer.github.io/2017/05/16/Vue%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://silkyer.github.io/2017/05/16/Vue一些知识点/</id>
    <published>2017-05-16T06:14:01.965Z</published>
    <updated>2017-05-16T06:19:25.989Z</updated>
    
    <content type="html"><![CDATA[<p>1、</p>
<p>使用组件时，大多数可以传入到 Vue 构造器中的选项可以在注册组件时使用，有一个例外： data 必须是函数。 实际上，如果你使用的不是函数，那么 Vue 会在控制台发出警告，告诉你在组件中 data 必须是一个函数。</p>
<p>下面的例子会让所有的组件都同时发生变化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;Document&lt;/title&gt;</div><div class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"vue.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;div id=<span class="string">"example-2"</span>&gt;</div><div class="line">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</div><div class="line">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</div><div class="line">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">var data = &#123; counter: 0 &#125;</div><div class="line">Vue.component(<span class="string">'simple-counter'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;button v-on:click="counter += 1"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</div><div class="line">  // data 是一个函数，因此 Vue 不会警告，</div><div class="line">  // 但是我们为每一个组件返回了同一个对象引用</div><div class="line">  data: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    <span class="built_in">return</span> data</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">new Vue(&#123;</div><div class="line">  el: <span class="string">'#example-2'</span></div><div class="line">&#125;)</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt; </div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>由于这三个组件共享了同一个 data ， 因此增加一个 counter 会影响所有组件！我们可以通过为每个组件返回新的 data 对象来解决这个问题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">data: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">  <span class="built_in">return</span> &#123;</div><div class="line">    counter: 0</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/components.html#data-必须是函数" target="_blank" rel="external">https://cn.vuejs.org/v2/guide/components.html#data-必须是函数</a><br><a href="https://segmentfault.com/q/1010000007910818?_ea=1490198" target="_blank" rel="external">https://segmentfault.com/q/1010000007910818?_ea=1490198</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、&lt;/p&gt;
&lt;p&gt;使用组件时，大多数可以传入到 Vue 构造器中的选项可以在注册组件时使用，有一个例外： data 必须是函数。 实际上，如果你使用的不是函数，那么 Vue 会在控制台发出警告，告诉你在组件中 data 必须是一个函数。&lt;/p&gt;
&lt;p&gt;下面的例子会让所有的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue2.0仿外卖APP（一）</title>
    <link href="https://silkyer.github.io/2017/05/15/web-app01/"/>
    <id>https://silkyer.github.io/2017/05/15/web-app01/</id>
    <published>2017-05-15T15:19:24.724Z</published>
    <updated>2017-05-16T03:59:06.325Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习慕课网的课程：用vue.js做一个仿饿了么外卖APP的项目，现在也把流程啊什么的暂时先整理一下在这个博客上面。</p>
<p>当然，这个过程会有点长，不过确实能学到很多东西。</p>
<p>话不多说，马上开始吧。</p>
<p>注：当我们把用vue-cli脚手架搭建成的vue项目复制到其他地方时，要把node_modules目录删除，不然在其他地方无法执行cnpm run dev，这其中设计到路径的问题。删除之后要重新cnpm install。</p>
<blockquote>
<p><a href="https://segmentfault.com/q/1010000006912664" target="_blank" rel="external">https://segmentfault.com/q/1010000006912664</a></p>
<p><a href="https://www.zhihu.com/question/41409670?sort=created" target="_blank" rel="external">https://www.zhihu.com/question/41409670?sort=created</a></p>
</blockquote>
<h2 id="1-项目介绍"><a href="#1-项目介绍" class="headerlink" title="1.项目介绍"></a>1.项目介绍</h2><p>选用当前最火的MVVM框架作为这个项目的技术栈<br>MVVM架构：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-15/7937415-file_1494862122245_c931.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>View和model通过viewModel来通信，但数据发生变化，viewmodel能够观察到这种数据的变化，然后通知到对应的视图做自动更新；当用户操作view视图，viewModel也能监听到视图的变化，然后通知数据做改动，实现了数据的双向绑定。</p>
<p>应用场景：</p>
<p>针对具有复杂交互逻辑的前端应用；</p>
<p>它可以提供基础的架构抽象；</p>
<p>可以通过AJAX数据持久化，保证前端用户体验</p>
<p>好处：</p>
<p>当前端和数据做一些操作的时候，可以通过AJAX请求对后端做数据持久化，不需要刷新整个页面，只需要改动DOM里需要改动的那部分数据。特别是移动端应用场景，刷新页面太昂贵，会重新加载很多资源，虽然有些会被缓存，但是页面的DOM,JS,CSS都会被页面重新解析一遍，因此移动端页面通常会做出SPA单页应用。</p>
<p>该项目只提取饿了么其中一个模块–商家模块进行开发</p>
<h3 id="项目开发的一个完整流程"><a href="#项目开发的一个完整流程" class="headerlink" title="项目开发的一个完整流程"></a>项目开发的一个完整流程</h3><p>项目的需求分析–脚手架工具–数据mock–架构设计–代码编写–自测–编译打包等方面完全简讲述开发一个web的全流程，更好地了解一个项目从0到1的过程。</p>
<h3 id="所需技术："><a href="#所需技术：" class="headerlink" title="所需技术："></a>所需技术：</h3><p>项目完整的开发流程；组件化、模块化的开发模式；使用Vue-cli脚手架初始化Vue.js项目；webpack的打包原理；模拟json后端数据，前后端分离开发；es6+eslint的开发方式。</p>
<h3 id="第三方组件："><a href="#第三方组件：" class="headerlink" title="第三方组件："></a>第三方组件：</h3><p>使用stylus编写模块化的CSS；使用vue-router开发单页应用；使用vue-resource与后端数据交互；在Vue.js框架里和第三方JS插件交互。</p>
<h2 id="关于Vue的数据驱动思想"><a href="#关于Vue的数据驱动思想" class="headerlink" title="关于Vue的数据驱动思想"></a>关于Vue的数据驱动思想</h2><p>在数据驱动的思想里，数据驱动DOM变化，DOM是数据的一种自然映射。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-15/20491526-file_1494862564539_6edb.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>如果没有MVVM框架，数据和视图是如何交互的？</p>
<p>比如通过AJAX从后端获取数据，会让视图改变，通过手动触发DOM的改变；再比如我们通过前端交互改变一些数据，为了让视图也发生变化，仍然需要通过手动触发进行DOM改变。手动改变DOM不仅繁琐，还容易出错。用了vue之后就可以省去操作DOM变化的步骤了。</p>
<p>在vue.js中，可以通过directives指令去对DOM做一层封装，当数据发生变化，会通知指令去修改对应的DOM。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-15/25525927-file_1494863109212_18596.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>Vue.js还会对操作做监听，当我们修改视图的时候，vue.js监听到这些变化，从而改变数据。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-15/26985719-file_1494863223718_b6b4.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>(↑上面两幅图红色区域代表正在执行该逻辑)<br>这样就实现了数据的双向绑定。</p>
<h2 id="vue-js数据响应的原理"><a href="#vue-js数据响应的原理" class="headerlink" title="vue.js数据响应的原理"></a>vue.js数据响应的原理</h2><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>思路整理</p>
<p>已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一，如果不熟悉defineProperty，猛戳→<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">这里</a></p>
<p>整理了一下，要实现mvvm的双向绑定，就必须要实现以下几点：<br>1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者<br>2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数<br>3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br>4、mvvm入口函数，整合以上三者</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-15/57226083-file_1494863586565_920a.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>详情可查看: <a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="external">剖析Vue原理&amp;实现双向绑定MVVM</a> (先把app做出来,回头来研究)</p>
<h2 id="关于vue组件化的思想"><a href="#关于vue组件化的思想" class="headerlink" title="关于vue组件化的思想"></a>关于vue组件化的思想</h2><p>目的：拓展HTML元素，封装可重用代码</p>
<p>如下图：左侧是一个页面，被拆分成小的区块，每个区块对应一个组件，组件可以嵌套，最终组合成为一个完整页面。</p>
<p>在vue.js中，每个组件都对应一个viewModel，最终生成一个viewModel的树：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://opolpcrco.bkt.clouddn.com/17-5-15/26001293-file_1494863782367_266a.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="组件化讲解"><a href="#组件化讲解" class="headerlink" title="组件化讲解"></a>组件化讲解</h3><p>一个简单的HTML页面，以此为基础：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">       &lt;html&gt;</div><div class="line">             &lt;head&gt;</div><div class="line">                   &lt;title&gt;揭开Vue组件的神秘面纱&lt;/title&gt;</div><div class="line">             &lt;/head&gt;</div><div class="line">       &lt;body&gt;</div><div class="line">             //这中间就是实例挂载点的实例边界</div><div class="line">             &lt;div id=<span class="string">"vueInstance"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">             &lt;script src=<span class="string">"http://cdn.jsdelivr.net/vue/1.0.16/vue.js"</span>&gt;&lt;/script&gt;</div><div class="line"></div><div class="line">             &lt;script&gt;</div><div class="line">                   // 创建一个新的Vue实例，并设置挂载点</div><div class="line">                   var V = new Vue(&#123;</div><div class="line">                         el : <span class="string">'#vueInstance'</span></div><div class="line">                   &#125;);</div><div class="line">             &lt;/script&gt;</div><div class="line">       &lt;/body&gt;</div><div class="line"> &lt;/html&gt;</div></pre></td></tr></table></figure>
<p>在Vue中，可以使用Vue.component()来创建和注册你的组件，这个构造器有两个参数：组件的名字；包含组件参数的对象。</p>
<p>接下来注册一个组件。创建并传入两个参数：组件的名字:’mine’；包含组件参数的对象:这个对象包含一个属性’template’。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'mine'</span>,&#123;</div><div class="line">    template : <span class="string">'&lt;p&gt;My name is Appian.&lt;/p&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>现在你已经有了自己的一个组件了，你可以在你的应用的任何地方使用它。只要你调用它的唯一标识(就是组件名字)，并用普通html标签的格式来书写，比如<mine></mine>，组件上注册的内容就会在你的自定义标签的地方插入。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;vue组件&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=<span class="string">"vueInstance"</span>&gt;</div><div class="line">        &lt;mine&gt;&lt;/mine&gt;   </div><div class="line">        &lt;mine&gt;&lt;/mine&gt;</div><div class="line">        &lt;mine&gt;&lt;/mine&gt;   </div><div class="line">     &lt;/div&gt;</div><div class="line">    &lt;script src=<span class="string">"http://cdn.jsdelivr.net/vue/1.0.16/vue.js"</span>&gt;&lt;/script&gt;</div><div class="line">     &lt;script&gt;</div><div class="line">        Vue.component(<span class="string">'mine'</span>,&#123;   //这里就是注册的内容</div><div class="line">            template : <span class="string">'&lt;p&gt;My name is Vue.&lt;/p&gt;'</span></div><div class="line">        &#125;);</div><div class="line">       // 创建一个新的Vue实例，并设置挂载点</div><div class="line">       var V = new Vue(&#123;</div><div class="line">             el : <span class="string">'#vueInstance'</span></div><div class="line">       &#125;);</div><div class="line">     &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h3 id="利用template标签处理复杂组件"><a href="#利用template标签处理复杂组件" class="headerlink" title="利用template标签处理复杂组件"></a>利用template标签处理复杂组件</h3><p>如果总是在vue.component()构造器里写html代码，复杂页面就不得了了。为了避免上面的这种情况，所以我们可以用template标签（注意属性和标签是不一样的）来达到我们的目的。我们可以在页面的任何地方，定义template标签，并在template标签内，写好我们的模板。</p>
<blockquote>
<p>因为template标签在页面加载的时候不会渲染出来，只有在我们需要它的时候，这个标签内的内容才会被渲染出来。所以，你可以把template标签放在任何地方，并给它一个id，以便在组件注册的时候能够找到模板。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;vue组件&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=<span class="string">"vueInstance"</span>&gt;</div><div class="line">        &lt;mine&gt;&lt;/mine&gt;     </div><div class="line">     &lt;/div&gt;</div><div class="line"></div><div class="line">    &lt;template id=<span class="string">"myVue"</span>&gt;</div><div class="line">        &lt;p&gt;i am vue&lt;/p&gt;</div><div class="line">        &lt;p&gt;welcome!&lt;/p&gt;</div><div class="line">    &lt;/template&gt;</div><div class="line"></div><div class="line">    &lt;script src=<span class="string">"http://cdn.jsdelivr.net/vue/1.0.16/vue.js"</span>&gt;&lt;/script&gt;</div><div class="line">     &lt;script&gt;</div><div class="line">        Vue.component(<span class="string">'mine'</span>,&#123;   //这里就是注册的内容</div><div class="line">            template : <span class="string">'#myVue'</span></div><div class="line">        &#125;);</div><div class="line">       // 创建一个新的Vue实例，并设置挂载点</div><div class="line">       var V = new Vue(&#123;</div><div class="line">             el : <span class="string">'#vueInstance'</span></div><div class="line">       &#125;);</div><div class="line">     &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h3 id="通过props向组件中传递数据"><a href="#通过props向组件中传递数据" class="headerlink" title="通过props向组件中传递数据"></a>通过props向组件中传递数据</h3><p>Vue是处理父组件向子组件中传递数据是通过props。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'mine'</span>,&#123;</div><div class="line">    template : <span class="string">'&lt;p&gt;Appian is from &#123;&#123; city &#125;&#125;.&lt;/p&gt;'</span>,</div><div class="line">    props : [<span class="string">'city'</span>]</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>props可以是数组，也可以是对象。</p>
<p>那父组件那里又是怎么指派字段给子组件的呢？</p>
<p>只需要在对应的标签内写下属性就好</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;mine city=<span class="string">"welcome"</span>&gt;&lt;/mine&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习慕课网的课程：用vue.js做一个仿饿了么外卖APP的项目，现在也把流程啊什么的暂时先整理一下在这个博客上面。&lt;/p&gt;
&lt;p&gt;当然，这个过程会有点长，不过确实能学到很多东西。&lt;/p&gt;
&lt;p&gt;话不多说，马上开始吧。&lt;/p&gt;
&lt;p&gt;注：当我们把用vue-cli脚手架搭
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://silkyer.github.io/2017/05/13/hello-world/"/>
    <id>https://silkyer.github.io/2017/05/13/hello-world/</id>
    <published>2017-05-13T06:07:47.892Z</published>
    <updated>2017-05-13T06:07:47.925Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
